<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radashkovichy Restoration Plans 1888-1891</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet Gesture Handling CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-gesture-handling@1.2.2/dist/leaflet-gesture-handling.min.css"
          crossorigin=""/>

    <style>
        /* ========================================
           RESET & BASE STYLES
           ======================================== */

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #f5f5f5;
        }

        /* ========================================
           LAYOUT
           ======================================== */

        #page-header {
            background: white;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #page-title {
            font-size: 28px;
            font-weight: bold;
            color: #2c5f2d;
            margin: 0 0 20px 0;
            line-height: 1.4;
        }

        #page-description {
            font-size: 16px;
            color: #666;
            line-height: 1.6;
            max-width: 900px;
            margin: 0 auto;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            min-height: 60px;
        }

        #container {
            max-width: 1600px;
            margin: 30px auto;
            padding: 0 20px;
        }

        #map-section {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        #map {
            width: 100%;
            height: 600px;
            background-color: #f0f0f0;
        }

        /* ========================================
           TABLE SECTION
           ======================================== */

        #table-section {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        #table-header {
            background: #2c5f2d;
            color: white;
            padding: 0;
        }

        #table-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 30px;
        }

        #table-title {
            font-size: 18px;
            font-weight: bold;
            margin: 0;
        }

        #filters-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: background 0.2s;
        }

        #filters-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #filters-toggle-text {
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
        }

        #filters-active-badge {
            display: none;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }

        #filters-active-badge.show {
            display: inline-block;
        }

        #filters-toggle-icon {
            font-size: 14px;
            color: white;
            transition: transform 0.3s;
        }

        #filters-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        #filters-content {
            padding: 20px 30px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            max-height: 500px;
            opacity: 1;
            background: white;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        #filters-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        #search-wrapper {
            margin-bottom: 10px;
        }

        #search-input {
            width: 100%;
            padding: 8px 28px 8px 12px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .filters-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .filter-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .filter-label {
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 4px;
            color: #555;
        }

        .filter-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .filter-input,
        .filter-select {
            padding: 6px 28px 6px 8px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            flex: 1;
        }

        .filter-select {
            cursor: pointer;
        }

        .clear-filter {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: #999;
            font-size: 16px;
            padding: 2px 6px;
            display: none;
            background: transparent;
            border: none;
            line-height: 1;
        }

        .clear-filter:hover {
            color: #d32f2f;
        }

        .filter-wrapper.has-value .clear-filter {
            display: block;
        }

        /* Multiselect dropdown */
        .multiselect-dropdown {
            position: relative;
            width: 100%;
        }

        .multiselect-selected {
            padding: 6px 28px 6px 8px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            min-height: 30px;
            display: flex;
            align-items: center;
        }

        .multiselect-selected:hover {
            border-color: #999;
        }

        .multiselect-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 2px;
            display: none;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .multiselect-options.show {
            display: block;
        }

        .multiselect-option {
            padding: 6px 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            font-size: 13px;
        }

        .multiselect-option:hover {
            background: #f5f5f5;
        }

        .multiselect-option input[type="checkbox"] {
            margin-right: 8px;
        }

        .multiselect-placeholder {
            color: #999;
        }

        .multiselect-count {
            color: #2c5f2d;
            font-weight: bold;
        }

        #table-container {
            background: white;
            max-height: 600px;
            overflow-y: auto;
            overflow-x: auto;
            scroll-behavior: smooth;
        }

        /* ========================================
           DATA TABLE
           ======================================== */

        #data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        /* Table Header */
        #data-table thead {
            position: sticky;
            top: 0;
            background: #2c5f2d;
            color: white;
            z-index: 10;
        }

        #data-table th {
            padding: 10px 8px;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #1a3a1b;
            cursor: pointer;
            user-select: none;
            position: relative;
            white-space: nowrap;
        }

        #data-table th:hover {
            background: #3a7a3d;
        }

        /* Sort Indicators */
        #data-table th[data-sort]::after {
            content: ' ⇅';
            opacity: 0.3;
            font-size: 12px;
            margin-left: 5px;
        }

        #data-table th.sort-asc::after {
            content: ' ▲';
            opacity: 1;
        }

        #data-table th.sort-desc::after {
            content: ' ▼';
            opacity: 1;
        }

        /* Table Cells */
        #data-table td {
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
        }

        /* Table Rows */
        #data-table tbody tr {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #data-table tbody tr:hover {
            background-color: #f0f8f0;
        }

        #data-table tbody tr.selected {
            background-color: #c8e6c9 !important;
            border-left: 4px solid #2c5f2d;
        }

        #data-table tbody tr.selected:hover {
            background-color: #b8d6b8 !important;
        }

        #data-table tbody tr:nth-child(even) {
            background-color: #fafafa;
        }

        #data-table tbody tr:nth-child(even):hover {
            background-color: #f0f8f0;
        }

        /* ========================================
           MAP OVERLAYS
           ======================================== */

        /* Plot Number Labels */
        .field-label {
            background: transparent;
            border: none;
            padding: 2px 4px;
            font-size: 12px;
            font-weight: bold;
            color: #2c5f2d;
            text-align: center;
            pointer-events: none;
            transition: opacity 0.3s;
            white-space: nowrap;
            overflow: visible;
        }

        .field-label-hidden {
            opacity: 0;
        }

        /* Street Name Labels */
        .leaflet-text-path {
            font-size: 12px;
            font-weight: bold;
            fill: #333;
            paint-order: stroke;
            stroke: white;
            stroke-width: 3px;
            stroke-linecap: round;
            stroke-linejoin: round;
            transition: opacity 0.3s;
        }

        .leaflet-text-path-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* Popup Content */
        .leaflet-popup-content {
            margin: 10px;
            line-height: 1.4;
        }

        .popup-info {
            font-size: 13px;
            margin: 5px 0;
        }

        /* Map Legend */
        .legend {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            line-height: 20px;
            font-size: 12px;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .legend-item {
            margin: 3px 0;
        }

        .legend-color {
            display: inline-block;
            width: 20px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #333;
            vertical-align: middle;
        }

        /* ========================================
           MAP NAVIGATION CONTROL
           ======================================== */

        .map-navigation {
            background: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            margin-top: 10px;
        }

        .map-navigation-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 12px;
            color: #333;
        }

        .map-navigation-buttons {
            display: flex;
            gap: 5px;
        }

        .map-nav-btn {
            flex: 1;
            padding: 6px 10px;
            background: #f4f4f4;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            transition: all 0.2s;
            color: #333;
        }

        .map-nav-btn:hover {
            background: #2c5f2d;
            color: white;
            border-color: #2c5f2d;
        }

        .map-nav-btn.active {
            background: #2c5f2d;
            color: white;
            border-color: #2c5f2d;
        }

        /* ========================================
           LOADING STATE
           ======================================== */

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 9999;
        }

        /* ========================================
           FOOTER
           ======================================== */

        footer {
            background: #2c5f2d;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 13px;
            width: 100%;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
            margin-top: 30px;
        }

        footer a {
            color: #90EE90;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .footer-section {
            flex: 1;
            min-width: 250px;
        }

        /* ========================================
           RESPONSIVE DESIGN
           ======================================== */

        /* Tablets */
        @media (max-width: 1024px) {
            #page-header {
                padding: 25px 30px;
            }

            #page-title {
                font-size: 24px;
            }

            #page-description {
                font-size: 15px;
            }

            #container {
                padding: 0 15px;
                margin: 20px auto;
            }

            #map {
                height: 500px;
            }

            #table-header-top {
                padding: 10px 20px;
            }

            #table-title {
                font-size: 17px;
            }

            #filters-content {
                padding: 18px 20px;
            }
        }

        /* Mobile */
        @media (max-width: 768px) {
            #page-header {
                padding: 20px 15px;
            }

            #page-title {
                font-size: 20px;
            }

            #page-description {
                font-size: 14px;
                padding: 12px;
            }

            #container {
                padding: 0 10px;
                margin: 15px auto;
            }

            #map {
                height: 400px;
            }

            #table-header-top {
                padding: 10px 20px;
            }

            #table-title {
                font-size: 16px;
            }

            #filters-toggle {
                padding: 5px 10px;
            }

            #filters-toggle-text {
                font-size: 12px;
            }

            #filters-content {
                padding: 15px 20px;
            }

            #table-container {
                max-height: 400px;
            }

            footer {
                padding: 15px 10px;
                font-size: 11px;
            }

            .footer-content {
                flex-direction: column;
                gap: 8px;
            }

            .footer-section {
                min-width: 100%;
                text-align: center;
            }

            .filters-row {
                flex-direction: column;
            }

            .filter-group {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Map loading...</div>

    <header id="page-header">
        <h1 id="page-title">Plans for the restoration of Radoshkovichi after the fires of 1888 and 1891 (indicating land plots and owners)</h1>
        <div id="page-description">
            <!-- Description text will be added here -->
        </div>
    </header>

    <div id="container">
        <div id="map-section">
            <div id="map"></div>
        </div>

        <div id="table-section">
            <div id="table-header">
                <div id="table-header-top">
                    <h2 id="table-title">Land Plots</h2>
                    <div id="filters-toggle">
                        <span id="filters-toggle-text">
                            Filters
                            <span id="filters-active-badge"></span>
                        </span>
                        <span id="filters-toggle-icon">▼</span>
                    </div>
                </div>

                <div id="filters-content">
                    <div class="filter-wrapper" id="search-wrapper">
                        <input type="text" id="search-input" placeholder="Find anything in the table">
                        <button class="clear-filter" id="clear-search" title="Clear search">×</button>
                    </div>

                    <div class="filters-row">
                        <div class="filter-group">
                            <label class="filter-label">Owner Name:</label>
                            <div class="filter-wrapper" id="owner-filter-wrapper">
                                <input type="text" id="filter-owner" class="filter-input" placeholder="Filter by owner...">
                                <button class="clear-filter" id="clear-owner" title="Clear filter">×</button>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Plan Part:</label>
                            <div class="filter-wrapper">
                                <div class="multiselect-dropdown" id="planpart-multiselect">
                                    <div class="multiselect-selected">
                                        <span class="multiselect-placeholder">Select Plan Parts...</span>
                                    </div>
                                    <div class="multiselect-options"></div>
                                </div>
                                <button class="clear-filter" id="clear-planpart" title="Clear selection" style="display: none;">×</button>
                            </div>
                        </div>
                    </div>

                    <div class="filters-row">
                        <div class="filter-group">
                            <label class="filter-label">Plan:</label>
                            <select id="filter-map" class="filter-select" style="padding: 6px 8px;">
                                <option value="">All Plans</option>
                                <option value="map1">Restoration plan 1888</option>
                                <option value="map2">Restoration plan 1891</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div id="table-container">
                <table id="data-table">
                    <thead>
                        <tr>
                            <th data-sort="number">No.</th>
                            <th data-sort="firstnametranslit">First name (translit)</th>
                            <th data-sort="lastnametranslit">Last name (translit)</th>
                            <th data-sort="patronymictranslit">Patronymic (translit)</th>
                            <th data-sort="firstnamenative">First name (native)</th>
                            <th data-sort="lastnamenative">Last name (native)</th>
                            <th data-sort="patronymicnative">Patronymic (native)</th>
                            <th data-sort="length">Length</th>
                            <th data-sort="width">Width</th>
                            <th data-sort="planpart">Plan part</th>
                            <th data-sort="owneroriginal">Owner Name (original)</th>
                        </tr>
                    </thead>
                    <tbody id="data-table-body">
                        <!-- Data will be loaded via JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet Gesture Handling Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-gesture-handling@1.2.2/dist/leaflet-gesture-handling.min.js"
            crossorigin=""></script>

    <!-- Leaflet TextPath Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-textpath@1.2.3/leaflet.textpath.min.js"></script>

    <script>
        // ========================================
        // APPLICATION INITIALIZATION
        // ========================================

        window.addEventListener('load', function() {
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';

            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                alert('Error: The library Leaflet was not loaded. Check your internet connection.');
                return;
            }

            // ========================================
            // MAP CONFIGURATION
            // ========================================

            const mapCenter = [54.158000, 27.237500]; // Center between both maps
            const initialZoom = 16;
            const minZoomForLabels = 18; // Minimum zoom level to show labels
            
            // ========================================
            // MAP INITIALIZATION
            // ========================================

            const map = L.map('map', {
                gestureHandling: true,
                gestureHandlingOptions: {
                    text: {
                        touch: "Use two fingers to move the map",
                        scroll: "Use Ctrl + scroll to zoom the map",
                        scrollMac: "Use ⌘ + scroll to zoom the map"
                    }
                }
            }).setView(mapCenter, initialZoom);

            // OpenStreetMap base layer
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 22,
                maxNativeZoom: 19
            }).addTo(map);

            // ========================================
            // POPUP CONTENT GENERATION
            // ========================================

            // Create popup content for land plots
            function createPopupContent(props, sourceLayer) {
                let popupContent = '';
                let hasData = false;

                // Determine field names based on source layer
                const isMap2 = sourceLayer === 'map2-polygons1';
                const lengthField = isMap2 ? 'Length of plot' : 'Length of plots';
                const widthField = isMap2 ? 'Width of plot' : 'Width of plots';

                // Field Number
                if (props['Field number']) {
                    popupContent += `<div class="popup-info"><b>Field Number:</b> ${props['Field number']}</div>`;
                    hasData = true;
                }

                // Owner Name (translit) - first
                if (props['Name translit']) {
                    popupContent += `<div class="popup-info"><b>Owner Name (translit):</b> ${props['Name translit']}</div>`;
                    hasData = true;
                }

                // Owner Name (native) - second
                if (props['Name native']) {
                    popupContent += `<div class="popup-info"><b>Owner Name (native):</b> ${props['Name native']}</div>`;
                    hasData = true;
                }

                // Length
                if (props[lengthField]) {
                    popupContent += `<div class="popup-info"><b>Length:</b> ${props[lengthField]} sazhens</div>`;
                    hasData = true;
                }

                // Width
                if (props[widthField]) {
                    popupContent += `<div class="popup-info"><b>Width:</b> ${props[widthField]} sazhens</div>`;
                    hasData = true;
                }

                return hasData ? popupContent : null;
            }

            // ========================================
            // LAYER STYLING FUNCTIONS
            // ========================================

            // Determine feature style based on source layer
            function getFeatureStyle(feature) {
                const sourceLayer = feature.properties.source_layer;
                const props = feature.properties;

                // Street boundaries (lines)
                if (sourceLayer === 'lines') {
                    return {
                        color: props.stroke_color || '#808080',
                        weight: props.stroke_width || 2,
                        opacity: 1,
                        dashArray: props.dash_array || ''
                    };
                }

                // Land plots (polygons1)
                if (sourceLayer === 'polygons1') {
                    return {
                        fillColor: props.fill_color || '#90EE90',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#2d5f2d',
                        weight: props.stroke_width || 2,
                        opacity: 1
                    };
                }

                // Plot subdivisions (polygons2)
                if (sourceLayer === 'polygons2') {
                    return {
                        fillColor: props.fill_color || '#FFB6C1',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#C71585',
                        weight: props.stroke_width || 2,
                        opacity: 1
                    };
                }

                // Buildings (polygons3)
                if (sourceLayer === 'polygons3') {
                    return {
                        fillColor: props.fill_color || '#FFD700',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#DAA520',
                        weight: props.stroke_width || 2,
                        opacity: 1
                    };
                }

                // Map 2 land plots (map2-polygons1)
                if (sourceLayer === 'map2-polygons1') {
                    return {
                        fillColor: props.fill_color || '#90EE90',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#2d5f2d',
                        weight: props.stroke_width || 2,
                        opacity: 1
                    };
                }

                // Default style
                return {
                    fillColor: '#cccccc',
                    fillOpacity: 0.5,
                    color: '#666666',
                    weight: 2,
                    opacity: 1
                };
            }

            // ========================================
            // GLOBAL LAYER VARIABLES
            // ========================================

            let combinedLayer; // Combined GeoJSON layer with all features
            let map2Layer; // Map 2 GeoJSON layer
            let fieldLabelsGroup = L.layerGroup(); // Group for plot number markers for map1
            let map2LabelsGroup = L.layerGroup(); // Group for plot number markers for map2
            let streetLayers = []; // Array to store street lines with names

            // ========================================
            // DATA LOADING
            // ========================================

            // Load all GeoJSON files in parallel
            Promise.all([
                fetch('data/map1-polygons.geojson').then(r => r.json()),
                fetch('data/map1-buildings.geojson').then(r => r.json()),
                fetch('data/map1-buildings2.geojson').then(r => r.json()),
                fetch('data/map2-polygons.geojson').then(r => r.json())
            ])
            .then(([polygons1Data, polygons3Data, polygons2Data, map2PolygonsData]) => {
                console.log('✓ All files loaded');

                // Tag each feature with its source layer for proper styling
                polygons1Data.features.forEach(f => f.properties.source_layer = 'polygons1');
                polygons2Data.features.forEach(f => f.properties.source_layer = 'polygons2');
                polygons3Data.features.forEach(f => f.properties.source_layer = 'polygons3');
                map2PolygonsData.features.forEach(f => f.properties.source_layer = 'map2-polygons1');

                // Combine all features into a single array
                const allFeatures = [
                    ...polygons1Data.features,
                    ...polygons2Data.features,
                    ...polygons3Data.features
                ];

                // Sort by layer_order (features without layer_order go last)
                allFeatures.sort((a, b) => {
                    const orderA = a.properties.layer_order !== undefined ? a.properties.layer_order : Infinity;
                    const orderB = b.properties.layer_order !== undefined ? b.properties.layer_order : Infinity;
                    return orderA - orderB;
                });

                console.log(`✓ Sorted ${allFeatures.length} features by layer_order`);

                // Create combined GeoJSON object
                const combinedGeoJSON = {
                    type: 'FeatureCollection',
                    features: allFeatures
                };

                // ========================================
                // CREATE COMBINED LAYER
                // ========================================

                combinedLayer = L.geoJSON(combinedGeoJSON, {
                    style: getFeatureStyle,
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        const sourceLayer = props.source_layer;

                        // Configure popups and interactions for land plots
                        if (sourceLayer === 'polygons1') {
                            // Create popup content using shared function
                            const popupContent = createPopupContent(props, sourceLayer);

                            // Bind popup only if there is data
                            if (popupContent) {
                                layer.bindPopup(popupContent);

                                // Add event listener for when popup opens
                                layer.on('popupopen', function() {
                                    // Highlight corresponding row in table
                                    document.querySelectorAll('#data-table tbody tr.selected').forEach(row => {
                                        row.classList.remove('selected');
                                    });
                                    document.querySelectorAll('#data-table tbody tr').forEach(row => {
                                        if (row.dataset.fid == props.fid) {
                                            row.classList.add('selected');
                                            // Scroll row to top only if clicked on map (not from table)
                                            if (!openedFromTableClick) {
                                                scrollRowIntoView(row);
                                            }
                                        }
                                    });
                                });
                            }

                            // Create plot number marker
                            if (props['Field number']) {
                                const center = layer.getBounds().getCenter();

                                // Check current zoom to set initial visibility
                                const currentZoom = map.getZoom();
                                const initialClass = currentZoom >= minZoomForLabels ? 'field-label' : 'field-label field-label-hidden';

                                const marker = L.marker(center, {
                                    icon: L.divIcon({
                                        className: initialClass,
                                        html: props['Field number'],
                                        iconSize: [30, 20],
                                        iconAnchor: [15, 10]
                                    })
                                });

                                // Click on marker opens popup from parent polygon
                                marker.on('click', function(e) {
                                    if (layer.getPopup()) {
                                        layer.openPopup(e.latlng);
                                    }
                                });

                                // Add marker to plot numbers group
                                fieldLabelsGroup.addLayer(marker);
                            }

                            // Hover effects for land plots
                            layer.on('mouseover', function() {
                                layer.setStyle({weight: 4, fillOpacity: 0.9});
                            });
                            layer.on('mouseout', function() {
                                combinedLayer.resetStyle(layer);
                            });
                        }

                        // Buildings and subdivisions: show popup from underlying land plot
                        if (sourceLayer === 'polygons2' || sourceLayer === 'polygons3') {
                            layer.on('click', function(e) {
                                const clickedPoint = e.latlng;

                                // Find land plot (polygons1) under the clicked point
                                combinedLayer.eachLayer(function(l) {
                                    if (l.feature &&
                                        l.feature.properties.source_layer === 'polygons1' &&
                                        l.getBounds &&
                                        l.getBounds().contains(clickedPoint)) {

                                        if (l.getPopup()) {
                                            l.openPopup(clickedPoint);
                                        }
                                    }
                                });
                            });
                        }

                        // Street names along lines
                        if (sourceLayer === 'lines' && props['Street name'] && props['Street name'] !== null && props['Street name'] !== '') {
                            // Store street name for later use
                            layer._streetName = props['Street name'];

                            layer.setText(props['Street name'], {
                                repeat: false,
                                center: true,
                                offset: -8,
                                attributes: {
                                    'class': 'leaflet-text-path',
                                    'dy': '-3'
                                }
                            });

                            // Store for visibility management
                            streetLayers.push(layer);
                        }
                    }
                }).addTo(map);

                console.log('✓ Combined layer created and added to map');

                // ========================================
                // CREATE MAP 2 LAYER
                // ========================================

                map2Layer = L.geoJSON(map2PolygonsData, {
                    style: getFeatureStyle,
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        const sourceLayer = props.source_layer;

                        // Configure popups and interactions for map2 land plots
                        if (sourceLayer === 'map2-polygons1') {
                            // Create popup content using shared function
                            const popupContent = createPopupContent(props, sourceLayer);

                            // Bind popup only if there is data
                            if (popupContent) {
                                layer.bindPopup(popupContent);

                                // Add event listener for when popup opens
                                layer.on('popupopen', function() {
                                    // Highlight corresponding row in table
                                    document.querySelectorAll('#data-table tbody tr.selected').forEach(row => {
                                        row.classList.remove('selected');
                                    });
                                    document.querySelectorAll('#data-table tbody tr').forEach(row => {
                                        if (row.dataset.fid == props.fid) {
                                            row.classList.add('selected');
                                            // Scroll row to top only if clicked on map (not from table)
                                            if (!openedFromTableClick) {
                                                scrollRowIntoView(row);
                                            }
                                        }
                                    });
                                });
                            }

                            // Create plot number marker
                            if (props['Field number']) {
                                const center = layer.getBounds().getCenter();

                                // Check current zoom to set initial visibility
                                const currentZoom = map.getZoom();
                                const initialClass = currentZoom >= minZoomForLabels ? 'field-label' : 'field-label field-label-hidden';

                                const marker = L.marker(center, {
                                    icon: L.divIcon({
                                        className: initialClass,
                                        html: props['Field number'],
                                        iconSize: [30, 20],
                                        iconAnchor: [15, 10]
                                    })
                                });

                                // Click on marker opens popup from parent polygon
                                marker.on('click', function(e) {
                                    if (layer.getPopup()) {
                                        layer.openPopup(e.latlng);
                                    }
                                });

                                // Add marker to map2 plot numbers group
                                map2LabelsGroup.addLayer(marker);
                            }

                            // Hover effects for land plots
                            layer.on('mouseover', function() {
                                layer.setStyle({weight: 4, fillOpacity: 0.9});
                            });
                            layer.on('mouseout', function() {
                                map2Layer.resetStyle(layer);
                            });
                        }
                    }
                });

                console.log('✓ Map 2 layer created');

                // Create group combining historical map and plot numbers
                const historicalMapGroup = L.layerGroup([combinedLayer, fieldLabelsGroup]).addTo(map);
                const map2Group = L.layerGroup([map2Layer, map2LabelsGroup]).addTo(map);

                // Add layer control (both as checkboxes)
                const overlayMaps = {
                    "OpenStreetMap": osmLayer,
                    "Restoration plan 1888": historicalMapGroup,
                    "Restoration plan 1891": map2Group
                };

                L.control.layers(null, overlayMaps, {
                    collapsed: false,
                    position: 'topright'
                }).addTo(map);

                // ========================================
                // MAP NAVIGATION CONTROL
                // ========================================

                // Define map centers and zoom levels
                const map1Center = [54.154854, 27.240569]; // Map 1 center
                const map2Center = [54.161500, 27.235000]; // Map 2 center
                const navigationZoom = 18;

                // Create custom navigation control
                const MapNavigationControl = L.Control.extend({
                    options: {
                        position: 'topright'
                    },

                    onAdd: function(map) {
                        const container = L.DomUtil.create('div', 'leaflet-bar map-navigation');

                        container.innerHTML = `
                            <div class="map-navigation-title">Quick View:</div>
                            <div class="map-navigation-buttons">
                                <button class="map-nav-btn" data-view="map1">Plan 1888</button>
                                <button class="map-nav-btn" data-view="map2">Plan 1891</button>
                            </div>
                        `;

                        // Prevent map interactions when clicking on navigation
                        L.DomEvent.disableClickPropagation(container);
                        L.DomEvent.disableScrollPropagation(container);

                        return container;
                    }
                });

                const mapNavigation = new MapNavigationControl();
                mapNavigation.addTo(map);

                // Add click handlers for navigation buttons
                document.querySelectorAll('.map-nav-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const view = this.getAttribute('data-view');

                        // Remove active class from all buttons
                        document.querySelectorAll('.map-nav-btn').forEach(b => b.classList.remove('active'));
                        // Add active class to clicked button
                        this.classList.add('active');

                        // Handle view switching
                        if (view === 'map1') {
                            // Ensure Map 1 layer is visible
                            if (!map.hasLayer(historicalMapGroup)) {
                                map.addLayer(historicalMapGroup);
                            }
                            // Fly to Map 1 center
                            map.flyTo(map1Center, navigationZoom, {
                                duration: 1.5,
                                easeLinearity: 0.5
                            });
                        } else if (view === 'map2') {
                            // Ensure Map 2 layer is visible
                            if (!map.hasLayer(map2Group)) {
                                map.addLayer(map2Group);
                            }
                            // Fly to Map 2 center
                            map.flyTo(map2Center, navigationZoom, {
                                duration: 1.5,
                                easeLinearity: 0.5
                            });
                        }
                    });
                });

                // ========================================
                // LABEL VISIBILITY MANAGEMENT
                // ========================================

                // Update visibility of plot numbers and street names based on zoom level
                function updateLabelsVisibility() {
                    const zoom = map.getZoom();

                    // Toggle plot number visibility for map1
                    fieldLabelsGroup.eachLayer(marker => {
                        const element = marker.getElement();
                        if (element) {
                            if (zoom >= minZoomForLabels) {
                                element.classList.remove('field-label-hidden');
                            } else {
                                element.classList.add('field-label-hidden');
                            }
                        }
                    });

                    // Toggle plot number visibility for map2
                    map2LabelsGroup.eachLayer(marker => {
                        const element = marker.getElement();
                        if (element) {
                            if (zoom >= minZoomForLabels) {
                                element.classList.remove('field-label-hidden');
                            } else {
                                element.classList.add('field-label-hidden');
                            }
                        }
                    });

                    // Toggle street name visibility via CSS class
                    const allTextElements = document.querySelectorAll('text.leaflet-text-path');
                    allTextElements.forEach(el => {
                        if (zoom >= minZoomForLabels) {
                            el.classList.remove('leaflet-text-path-hidden');
                        } else {
                            el.classList.add('leaflet-text-path-hidden');
                        }
                    });
                }

                // Initialize label visibility
                updateLabelsVisibility();

                // Update on zoom and move events
                // moveend is needed because leaflet-textpath plugin redraws text on map pan
                map.on('zoomend moveend', updateLabelsVisibility);

                // Update label visibility when layers are added/removed via layer control
                map.on('overlayadd', function(e) {
                    // Check if the added layer contains our label groups
                    const zoom = map.getZoom();
                    const shouldHideLabels = zoom < minZoomForLabels;

                    // Use requestAnimationFrame for faster, smoother update
                    requestAnimationFrame(() => {
                        // Apply visibility based on current zoom immediately
                        fieldLabelsGroup.eachLayer(marker => {
                            const element = marker.getElement();
                            if (element) {
                                if (shouldHideLabels) {
                                    element.classList.add('field-label-hidden');
                                } else {
                                    element.classList.remove('field-label-hidden');
                                }
                            }
                        });

                        map2LabelsGroup.eachLayer(marker => {
                            const element = marker.getElement();
                            if (element) {
                                if (shouldHideLabels) {
                                    element.classList.add('field-label-hidden');
                                } else {
                                    element.classList.remove('field-label-hidden');
                                }
                            }
                        });
                    });
                });

                // ========================================
                // POPULATE TABLE
                // ========================================

                saveTableData(allFeatures, map2PolygonsData.features);
                populateTable(allTableData);
            })
            .catch(error => {
                console.error('Error loading layers:', error);
                alert('Failed to load map data. Please check that files exist in the data/ folder.');
            });

            // ========================================
            // TABLE POPULATION FUNCTIONS
            // ========================================

            // Populate table with feature data
            function populateTable(features) {
                const tableBody = document.getElementById('data-table-body');
                tableBody.innerHTML = '';

                let rowCount = 0;

                features.forEach((feature, index) => {
                    const props = feature.properties;
                    const isMap2 = props.source_layer === 'map2-polygons1';

                    const row = document.createElement('tr');
                    row.dataset.featureIndex = index;
                    row.dataset.fid = props.fid; // Unique feature ID for lookup
                    row.dataset.sourceLayer = props.source_layer; // Store source layer for lookup

                    // Extract data based on source
                    const displayNumber = props['Field number'] || '-';
                    const firstNameTranslit = props['First name translit'] || '-';
                    const lastNameTranslit = props['Last name translit'] || '-';
                    const patronymicTranslit = props['Patronymic translit'] || '-';
                    const firstNameNative = props['First name native'] || '-';
                    const lastNameNative = props['Last name native'] || '-';
                    const patronymicNative = props['Patronymic native'] || '-';
                    const length = isMap2 ? (props['Length of plot'] || '-') : (props['Length of plots'] || '-');
                    const width = isMap2 ? (props['Width of plot'] || '-') : (props['Width of plots'] || '-');
                    const planPart = isMap2 ? (props['Plan part en'] || '-') : '-';
                    const ownerOriginal = props['Name native'] || '-';

                    row.innerHTML = `
                        <td>${displayNumber}</td>
                        <td>${firstNameTranslit}</td>
                        <td>${lastNameTranslit}</td>
                        <td>${patronymicTranslit}</td>
                        <td>${firstNameNative}</td>
                        <td>${lastNameNative}</td>
                        <td>${patronymicNative}</td>
                        <td>${length}</td>
                        <td>${width}</td>
                        <td>${planPart}</td>
                        <td>${ownerOriginal}</td>
                    `;

                    // Click row to open popup on map
                    row.addEventListener('click', function() {
                        openPopupForPlot(this.dataset.fid, this.dataset.sourceLayer);
                    });

                    tableBody.appendChild(row);
                    rowCount++;
                });

                console.log(`✓ Table populated: ${rowCount} entries`);

                // Update header with count
                document.getElementById('table-title').textContent =
                    `Land Plots (${rowCount})`;
            }

            // Flag to track if popup was opened from table row click
            let openedFromTableClick = false;

            // Scroll row to the top of table container (without scrolling the page)
            function scrollRowIntoView(row) {
                const tableContainer = document.getElementById('table-container');
                const tableHeader = document.querySelector('#data-table thead');
                const headerHeight = tableHeader ? tableHeader.offsetHeight : 0;

                // Calculate row position relative to table start
                const rowTop = row.offsetTop;

                // Scroll so the row appears right below the sticky header
                tableContainer.scrollTop = rowTop - headerHeight - 5; // 5px padding
            }

            // Open popup for plot when clicking table row (called from table row click)
            function openPopupForPlot(fid, sourceLayer) {
                // Set flag to prevent scrolling when popup opens
                openedFromTableClick = true;

                // Clear previous table selection
                document.querySelectorAll('#data-table tbody tr.selected').forEach(row => {
                    row.classList.remove('selected');
                });

                // Highlight selected row (but don't scroll yet)
                document.querySelectorAll('#data-table tbody tr').forEach(row => {
                    if (row.dataset.fid == fid) {
                        row.classList.add('selected');
                    }
                });

                // Determine which layer to search based on sourceLayer
                const targetLayer = sourceLayer === 'map2-polygons1' ? map2Layer : combinedLayer;
                const targetSourceLayer = sourceLayer === 'map2-polygons1' ? 'map2-polygons1' : 'polygons1';

                if (!targetLayer) return;

                // Find layer by unique feature ID
                targetLayer.eachLayer(function(layer) {
                    if (layer.feature &&
                        layer.feature.properties.source_layer === targetSourceLayer &&
                        layer.feature.properties.fid == fid) {

                        const center = layer.getBounds().getCenter();

                        // Pan and zoom to plot (without animating to prevent page scroll)
                        map.setView(center, Math.max(map.getZoom(), 18), { animate: false });

                        // Open popup
                        if (layer.getPopup()) {
                            layer.openPopup();
                        }
                    }
                });

                // Reset flag after popup opens
                setTimeout(() => {
                    openedFromTableClick = false;
                }, 100);
            }

            // ========================================
            // SEARCH AND SORT IN TABLE
            // ========================================

            let allTableData = [];
            let currentSortColumn = null; // No column sorted by default (initial sort is by plan and owner)
            let currentSortDirection = 'asc'; // ascending

            // Save data for search and sort
            function saveTableData(features, map2Features) {
                // Filter map1 features (polygons1) with plot number
                const map1Data = features.filter(feature => {
                    const sourceLayer = feature.properties.source_layer;
                    const props = feature.properties;

                    return sourceLayer === 'polygons1' &&
                           props['Field number'] !== null &&
                           props['Field number'] !== undefined &&
                           props['Field number'] !== '';
                });

                // Filter map2 features with Field number field
                const map2Data = map2Features.filter(feature => {
                    const props = feature.properties;
                    return props['Field number'] !== null &&
                           props['Field number'] !== undefined &&
                           props['Field number'] !== '';
                });

                // Combine both datasets
                allTableData = [...map1Data, ...map2Data];

                // Populate Plan part filter options
                populatePlanPartFilter();

                // Apply default sorting by plan and owner name
                initialSortTableData();
            }

            // Track selected plan parts
            let selectedPlanParts = new Set();

            // Populate Plan part multiselect with unique values
            function populatePlanPartFilter() {
                const uniquePlanParts = new Set();

                // Collect unique Plan part values from map2 data
                allTableData.forEach(feature => {
                    const props = feature.properties;
                    const isMap2 = props.source_layer === 'map2-polygons1';

                    if (isMap2 && props['Plan part en']) {
                        uniquePlanParts.add(props['Plan part en']);
                    }
                });

                // Get the options container
                const optionsContainer = document.querySelector('#planpart-multiselect .multiselect-options');
                optionsContainer.innerHTML = '';

                // Add checkboxes for each unique plan part
                Array.from(uniquePlanParts).sort().forEach(planPart => {
                    const option = document.createElement('div');
                    option.className = 'multiselect-option';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = planPart;
                    checkbox.id = `planpart-${planPart}`;

                    const label = document.createElement('label');
                    label.textContent = planPart;
                    label.htmlFor = `planpart-${planPart}`;
                    label.style.cursor = 'pointer';
                    label.style.flex = '1';

                    option.appendChild(checkbox);
                    option.appendChild(label);

                    // Handle checkbox change
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedPlanParts.add(this.value);
                        } else {
                            selectedPlanParts.delete(this.value);
                        }
                        updatePlanPartDisplay();
                        applyFilters();
                    });

                    optionsContainer.appendChild(option);
                });

                // Initialize display
                updatePlanPartDisplay();
            }

            // Update the multiselect display text
            function updatePlanPartDisplay() {
                const selectedDiv = document.querySelector('#planpart-multiselect .multiselect-selected');
                const clearButton = document.getElementById('clear-planpart');

                if (selectedPlanParts.size === 0) {
                    selectedDiv.innerHTML = '<span class="multiselect-placeholder">Select Plan Parts...</span>';
                    clearButton.style.display = 'none';
                } else {
                    selectedDiv.innerHTML = `<span class="multiselect-count">${selectedPlanParts.size} selected</span>`;
                    clearButton.style.display = 'block';
                }
            }

            // Toggle multiselect dropdown
            document.addEventListener('click', function(e) {
                const multiselect = document.getElementById('planpart-multiselect');
                const selected = multiselect.querySelector('.multiselect-selected');
                const options = multiselect.querySelector('.multiselect-options');

                if (selected.contains(e.target)) {
                    options.classList.toggle('show');
                } else if (!multiselect.contains(e.target)) {
                    options.classList.remove('show');
                }
            });

            // Sort table data
            function sortTableData(column, direction) {
                allTableData.sort((a, b) => {
                    let valueA, valueB;
                    const propsA = a.properties;
                    const propsB = b.properties;
                    const isMap2A = propsA.source_layer === 'map2-polygons1';
                    const isMap2B = propsB.source_layer === 'map2-polygons1';

                    switch(column) {
                        case 'number':
                            valueA = parseInt(propsA['Field number']) || 0;
                            valueB = parseInt(propsB['Field number']) || 0;
                            break;
                        case 'firstnametranslit':
                            valueA = (propsA['First name translit'] || '').toLowerCase();
                            valueB = (propsB['First name translit'] || '').toLowerCase();
                            break;
                        case 'lastnametranslit':
                            valueA = (propsA['Last name translit'] || '').toLowerCase();
                            valueB = (propsB['Last name translit'] || '').toLowerCase();
                            break;
                        case 'patronymictranslit':
                            valueA = (propsA['Patronymic translit'] || '').toLowerCase();
                            valueB = (propsB['Patronymic translit'] || '').toLowerCase();
                            break;
                        case 'firstnamenative':
                            valueA = (propsA['First name native'] || '').toLowerCase();
                            valueB = (propsB['First name native'] || '').toLowerCase();
                            break;
                        case 'lastnamenative':
                            valueA = (propsA['Last name native'] || '').toLowerCase();
                            valueB = (propsB['Last name native'] || '').toLowerCase();
                            break;
                        case 'patronymicnative':
                            valueA = (propsA['Patronymic native'] || '').toLowerCase();
                            valueB = (propsB['Patronymic native'] || '').toLowerCase();
                            break;
                        case 'length':
                            valueA = parseFloat(isMap2A ? propsA['Length of plot'] : propsA['Length of plots']) || 0;
                            valueB = parseFloat(isMap2B ? propsB['Length of plot'] : propsB['Length of plots']) || 0;
                            break;
                        case 'width':
                            valueA = parseFloat(isMap2A ? propsA['Width of plot'] : propsA['Width of plots']) || 0;
                            valueB = parseFloat(isMap2B ? propsB['Width of plot'] : propsB['Width of plots']) || 0;
                            break;
                        case 'planpart':
                            valueA = isMap2A ? (propsA['Plan part en'] || '').toLowerCase() : '';
                            valueB = isMap2B ? (propsB['Plan part en'] || '').toLowerCase() : '';
                            break;
                        case 'owneroriginal':
                            valueA = (propsA['Name native'] || '').toLowerCase();
                            valueB = (propsB['Name native'] || '').toLowerCase();
                            break;
                        default:
                            return 0;
                    }

                    // Check if values are empty (null, undefined, empty string, or just '-')
                    const isEmptyA = !valueA || valueA === '' || valueA === '-' || (typeof valueA === 'number' && valueA === 0);
                    const isEmptyB = !valueB || valueB === '' || valueB === '-' || (typeof valueB === 'number' && valueB === 0);

                    // Empty values always go last
                    if (isEmptyA && !isEmptyB) return 1;
                    if (!isEmptyA && isEmptyB) return -1;
                    if (isEmptyA && isEmptyB) return 0;

                    if (valueA < valueB) return direction === 'asc' ? -1 : 1;
                    if (valueA > valueB) return direction === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Initial sort by plan and then by owner name
            function initialSortTableData() {
                allTableData.sort((a, b) => {
                    const propsA = a.properties;
                    const propsB = b.properties;
                    const isMap2A = propsA.source_layer === 'map2-polygons1';
                    const isMap2B = propsB.source_layer === 'map2-polygons1';

                    // First, sort by plan (1888 before 1891)
                    if (!isMap2A && isMap2B) return -1; // plan 1888 before plan 1891
                    if (isMap2A && !isMap2B) return 1;  // plan 1891 after plan 1888

                    // Within each plan, sort by last name
                    const lastNameA = (propsA['Last name translit'] || propsA['Last name native'] || '').toLowerCase();
                    const lastNameB = (propsB['Last name translit'] || propsB['Last name native'] || '').toLowerCase();

                    // Check if last names are empty
                    const isEmptyA = !lastNameA || lastNameA === '' || lastNameA === '-';
                    const isEmptyB = !lastNameB || lastNameB === '' || lastNameB === '-';

                    // Empty last names always go last within their plan
                    if (isEmptyA && !isEmptyB) return 1;
                    if (!isEmptyA && isEmptyB) return -1;
                    if (isEmptyA && isEmptyB) return 0;

                    if (lastNameA < lastNameB) return -1;
                    if (lastNameA > lastNameB) return 1;
                    return 0;
                });
            }

            // Handle column header click for sorting
            function handleSort(column) {
                // Toggle direction if clicking the same column
                if (currentSortColumn === column) {
                    currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSortColumn = column;
                    currentSortDirection = 'asc';
                }

                sortTableData(currentSortColumn, currentSortDirection);

                // Re-apply all filters after sorting
                applyFilters();

                // Update visual indicators
                updateSortIndicators();
            }

            // Update sort indicators in table headers
            function updateSortIndicators() {
                document.querySelectorAll('#data-table th').forEach(th => {
                    th.classList.remove('sort-asc', 'sort-desc');
                    const sortColumn = th.getAttribute('data-sort');
                    if (sortColumn === currentSortColumn) {
                        th.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                    }
                });
            }

            // Update active filters badge
            function updateActiveFiltersBadge() {
                let activeCount = 0;

                const searchTerm = document.getElementById('search-input').value.trim();
                const ownerFilter = document.getElementById('filter-owner').value.trim();
                const mapFilter = document.getElementById('filter-map').value;

                if (searchTerm !== '') activeCount++;
                if (ownerFilter !== '') activeCount++;
                if (mapFilter !== '') activeCount++;
                if (selectedPlanParts.size > 0) activeCount++;

                const badge = document.getElementById('filters-active-badge');
                if (activeCount > 0) {
                    badge.textContent = activeCount + ' active';
                    badge.classList.add('show');
                } else {
                    badge.classList.remove('show');
                }
            }

            // Apply all filters (search + owner + plan part + map)
            function applyFilters() {
                // Get all filter values
                const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
                const ownerFilter = document.getElementById('filter-owner').value.toLowerCase().trim();
                const mapFilter = document.getElementById('filter-map').value;

                // Update clear button visibility
                updateClearButtonVisibility();

                // Update active filters badge
                updateActiveFiltersBadge();

                // Filter data
                const filtered = allTableData.filter(feature => {
                    const props = feature.properties;
                    const isMap2 = props.source_layer === 'map2-polygons1';

                    // Filter by map number
                    if (mapFilter !== '') {
                        if (mapFilter === 'map1' && isMap2) return false;
                        if (mapFilter === 'map2' && !isMap2) return false;
                    }

                    // Filter by search term (plot number or any name field)
                    if (searchTerm !== '') {
                        let matchesSearch = false;

                        // Check plot number
                        const fieldNumber = String(props['Field number'] || '').toLowerCase();
                        if (fieldNumber.includes(searchTerm)) matchesSearch = true;

                        // Check all name fields (translit)
                        const firstNameTranslit = String(props['First name translit'] || '').toLowerCase();
                        const lastNameTranslit = String(props['Last name translit'] || '').toLowerCase();
                        const patronymicTranslit = String(props['Patronymic translit'] || '').toLowerCase();
                        if (firstNameTranslit.includes(searchTerm) || lastNameTranslit.includes(searchTerm) || patronymicTranslit.includes(searchTerm)) {
                            matchesSearch = true;
                        }

                        // Check all name fields (native)
                        const firstNameNative = String(props['First name native'] || '').toLowerCase();
                        const lastNameNative = String(props['Last name native'] || '').toLowerCase();
                        const patronymicNative = String(props['Patronymic native'] || '').toLowerCase();
                        if (firstNameNative.includes(searchTerm) || lastNameNative.includes(searchTerm) || patronymicNative.includes(searchTerm)) {
                            matchesSearch = true;
                        }

                        // Check Owner Name (original)
                        const ownerOriginal = String(props['Name native'] || '').toLowerCase();
                        if (ownerOriginal.includes(searchTerm)) matchesSearch = true;

                        // Check Length
                        const length = String(isMap2 ? (props['Length of plot'] || '') : (props['Length of plots'] || '')).toLowerCase();
                        if (length.includes(searchTerm)) matchesSearch = true;

                        // Check Width
                        const width = String(isMap2 ? (props['Width of plot'] || '') : (props['Width of plots'] || '')).toLowerCase();
                        if (width.includes(searchTerm)) matchesSearch = true;

                        // Check plan part
                        if (isMap2) {
                            const planPart = String(props['Plan part en'] || '').toLowerCase();
                            if (planPart.includes(searchTerm)) matchesSearch = true;
                        }

                        if (!matchesSearch) return false;
                    }

                    // Filter by owner name
                    if (ownerFilter !== '') {
                        let matchesOwner = false;

                        // Check all name fields (translit)
                        const firstNameTranslit = String(props['First name translit'] || '').toLowerCase();
                        const lastNameTranslit = String(props['Last name translit'] || '').toLowerCase();
                        const patronymicTranslit = String(props['Patronymic translit'] || '').toLowerCase();
                        if (firstNameTranslit.includes(ownerFilter) || lastNameTranslit.includes(ownerFilter) || patronymicTranslit.includes(ownerFilter)) {
                            matchesOwner = true;
                        }

                        // Check all name fields (native)
                        const firstNameNative = String(props['First name native'] || '').toLowerCase();
                        const lastNameNative = String(props['Last name native'] || '').toLowerCase();
                        const patronymicNative = String(props['Patronymic native'] || '').toLowerCase();
                        if (firstNameNative.includes(ownerFilter) || lastNameNative.includes(ownerFilter) || patronymicNative.includes(ownerFilter)) {
                            matchesOwner = true;
                        }

                        // Check Owner Name (original)
                        const ownerOriginal = String(props['Name native'] || '').toLowerCase();
                        if (ownerOriginal.includes(ownerFilter)) {
                            matchesOwner = true;
                        }

                        if (!matchesOwner) return false;
                    }

                    // Filter by plan part (multiselect)
                    if (selectedPlanParts.size > 0) {
                        if (!isMap2) return false; // Plan part only exists in map2
                        const planPart = String(props['Plan part en'] || '');
                        if (!selectedPlanParts.has(planPart)) return false;
                    }

                    return true;
                });

                populateTable(filtered);
            }

            // Deprecated: kept for compatibility
            function searchTable(searchTerm) {
                applyFilters();
            }

            // Search handler (with delay for optimization)
            let searchTimeout;
            document.getElementById('search-input').addEventListener('input', function(e) {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300);
            });

            // Owner filter handler
            let ownerFilterTimeout;
            document.getElementById('filter-owner').addEventListener('input', function(e) {
                clearTimeout(ownerFilterTimeout);
                ownerFilterTimeout = setTimeout(() => {
                    applyFilters();
                }, 300);
            });

            // Map filter handler
            document.getElementById('filter-map').addEventListener('change', function(e) {
                applyFilters();
            });

            // Update clear button visibility based on filter values
            function updateClearButtonVisibility() {
                // Search input
                const searchInput = document.getElementById('search-input');
                const searchWrapper = document.getElementById('search-wrapper');
                if (searchInput.value.trim() !== '') {
                    searchWrapper.classList.add('has-value');
                } else {
                    searchWrapper.classList.remove('has-value');
                }

                // Owner filter input
                const ownerInput = document.getElementById('filter-owner');
                const ownerWrapper = document.getElementById('owner-filter-wrapper');
                if (ownerInput.value.trim() !== '') {
                    ownerWrapper.classList.add('has-value');
                } else {
                    ownerWrapper.classList.remove('has-value');
                }
            }

            // Clear search input
            document.getElementById('clear-search').addEventListener('click', function(e) {
                e.stopPropagation();
                document.getElementById('search-input').value = '';
                updateClearButtonVisibility();
                applyFilters();
            });

            // Clear owner filter
            document.getElementById('clear-owner').addEventListener('click', function(e) {
                e.stopPropagation();
                document.getElementById('filter-owner').value = '';
                updateClearButtonVisibility();
                applyFilters();
            });

            // Clear plan part filter
            document.getElementById('clear-planpart').addEventListener('click', function(e) {
                e.stopPropagation();
                // Uncheck all checkboxes
                selectedPlanParts.clear();
                document.querySelectorAll('#planpart-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updatePlanPartDisplay();
                applyFilters();
            });

            // Add click handlers to table headers for sorting
            document.querySelectorAll('#data-table th[data-sort]').forEach(th => {
                th.addEventListener('click', function() {
                    const column = this.getAttribute('data-sort');
                    handleSort(column);
                });
            });

            // Initialize sort indicators
            updateSortIndicators();

            // ========================================
            // FILTERS TOGGLE
            // ========================================

            // Hide filters by default
            const filtersContent = document.getElementById('filters-content');
            const filtersIcon = document.getElementById('filters-toggle-icon');
            filtersContent.classList.add('collapsed');
            filtersIcon.classList.add('collapsed');

            // Toggle filters visibility
            document.getElementById('filters-toggle').addEventListener('click', function() {
                filtersContent.classList.toggle('collapsed');
                filtersIcon.classList.toggle('collapsed');
            });

            // ========================================
            // MAP LEGEND
            // ========================================

            const legend = L.control({position: 'bottomleft'});

            legend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'legend');
                div.innerHTML = `
                    <div class="legend-title">Legend</div>
                    <div class="legend-item">
                        <span class="legend-color" style="background:#90EE90; border-color:#2d5f2d;"></span>
                        Land plots
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background:#FFB6C1; border-color:#C71585;"></span>
                        Plot subdivisions
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background:#FFD700; border-color:#DAA520;"></span>
                        Buildings
                    </div>
                `;
                return div;
            };

            legend.addTo(map);

            // ========================================
            // MAP SCALE
            // ========================================

            L.control.scale({
                imperial: false,
                metric: true,
                position: 'bottomleft'
            }).addTo(map);

            console.log('🗺️ Map initialized! Center:', mapCenter, 'Zoom:', initialZoom);
        });
    </script>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                Radashkovichy Restoration Plans 1888-1891
            </div>
            <div class="footer-section">
                Historical Map Visualization Project
            </div>
            <div class="footer-section">
                &copy; 2025 | Data: Historical Archives
            </div>
        </div>
    </footer>
</body>
</html>
