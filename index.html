<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mapping for local history projects: from archival document to user model</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet Gesture Handling CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-gesture-handling@1.2.2/dist/leaflet-gesture-handling.min.css"
          crossorigin=""/>

    <style>
        /* ========================================
           RESET & BASE STYLES
           ======================================== */

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow-y: auto;
            overflow-x: hidden;
            background-color: #f5f5f5;
        }

        /* ========================================
           LAYOUT
           ======================================== */

        #page-header {
            background: white;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #page-title {
            font-size: 28px;
            font-weight: bold;
            color: #2c5f2d;
            margin: 0 0 10px 0;
            line-height: 1.4;
            text-align: center;
        }

        #page-subtitle {
            font-size: 20px;
            font-weight: normal;
            color: #555;
            line-height: 1.4;
            text-align: center;
        }

        #page-description {
            font-size: 16px;
            color: #444;
            line-height: 1.7;
            max-width: 1600px;
            margin: 20px auto;
            padding: 30px 40px;
            background: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .user-guide-intro {
            margin-bottom: 28px;
            padding-bottom: 24px;
            border-bottom: 1px solid #ddd;
            color: #555;
            font-style: italic;
        }

        .user-guide-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
        }

        .guide-column h4 {
            color: #2c5f2d;
            font-size: 1.1em;
            font-weight: 600;
            margin-top: 0;
            margin-bottom: 14px;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .guide-column p {
            margin: 0 0 14px 0;
        }

        .guide-column p:last-child {
            margin-bottom: 0;
        }

        .guide-column ul {
            margin: 8px 0 14px 0;
            padding-left: 20px;
        }

        .guide-column li {
            margin-bottom: 6px;
        }

        @media (max-width: 768px) {
            .user-guide-content {
                grid-template-columns: 1fr;
                gap: 24px;
            }

            #page-description {
                padding: 20px;
                margin: 10px;
            }
        }

        #container {
            max-width: 1600px;
            margin: 30px auto;
            padding: 0 20px;
        }

        #map-section {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        #map {
            width: 100%;
            height: 600px;
            background-color: #f0f0f0;
        }

        /* ========================================
           TABLE SECTION
           ======================================== */

        #table-section {
            background: white;
            border-radius: 12px;
            overflow: visible;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        #table-header {
            background: #2c5f2d;
            color: white;
            padding: 0;
            border-radius: 12px 12px 0 0;
        }

        #table-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 30px;
        }

        #table-title {
            font-size: 18px;
            font-weight: bold;
            margin: 0;
        }

        #table-header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #csv-download {
            position: relative;
        }

        #csv-download-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: background 0.2s;
            font-size: 13px;
            color: white;
        }

        #csv-download-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .download-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 5px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 200px;
            z-index: 1000;
            overflow: hidden;
        }

        .download-menu.show {
            display: block;
        }

        .download-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
            transition: background 0.2s;
            white-space: nowrap;
        }

        .download-menu-item:hover {
            background: #f0f8f0;
        }

        .download-menu-item:active {
            background: #e0f0e0;
        }

        #filters-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            transition: background 0.2s;
        }

        #filters-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        #filters-toggle-text {
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
        }

        #filters-active-badge {
            display: none;
            background: rgba(255, 255, 255, 0.3);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
        }

        #filters-active-badge.show {
            display: inline-block;
        }

        #filters-toggle-icon {
            font-size: 14px;
            color: white;
            transition: transform 0.3s;
        }

        #filters-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        #filters-content {
            padding: 20px 30px;
            overflow: visible;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
            max-height: 500px;
            opacity: 1;
            background: white;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        #filters-content.collapsed {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            padding-bottom: 0;
            overflow: hidden;
        }

        #search-wrapper {
            margin-bottom: 10px;
        }

        #search-input {
            width: 100%;
            padding: 8px 28px 8px 36px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-image: url("data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 12C9.76142 12 12 9.76142 12 7C12 4.23858 9.76142 2 7 2C4.23858 2 2 4.23858 2 7C2 9.76142 4.23858 12 7 12Z' stroke='%23999' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3Cpath d='M14 14L10.5 10.5' stroke='%23999' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: left 12px center;
            background-size: 16px;
        }

        #search-input:focus {
            outline: none;
            border-color: #467148;
        }

        .filters-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .filter-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .filter-label {
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 4px;
            color: #555;
        }

        .filter-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .filter-input,
        .filter-select {
            padding: 6px 28px 6px 8px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            flex: 1;
        }

        .filter-input:focus {
            outline: none;
            border-color: #467148;
        }

        .filter-select {
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23666' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
        }

        .filter-select:hover {
            border-color: #999;
        }

        .filter-select:focus {
            outline: none;
            border-color: #467148;
        }

        .clear-filter {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: #999;
            font-size: 16px;
            padding: 2px 6px;
            display: none;
            background: transparent;
            border: none;
            line-height: 1;
        }

        .clear-filter:hover {
            color: #d32f2f;
        }

        .filter-wrapper.has-value .clear-filter {
            display: block;
        }

        /* Clear all filters button */
        #clear-all-filters-wrapper {
            display: none;
            text-align: right;
            margin-top: 15px;
        }

        #clear-all-filters-wrapper.show {
            display: block;
        }

        #clear-all-filters {
            background: white;
            color: #467148;
            border: 1px solid #467148;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        #clear-all-filters:hover {
            background: #467148;
            color: white;
        }

        /* Multiselect dropdown */
        .multiselect-dropdown {
            position: relative;
            width: 100%;
        }

        .multiselect-selected {
            padding: 6px 28px 6px 8px;
            font-size: 13px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            min-height: 30px;
            display: flex;
            align-items: center;
        }

        .multiselect-selected:hover {
            border-color: #999;
        }

        .multiselect-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-top: 2px;
            display: none;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .multiselect-options.show {
            display: block;
        }

        .multiselect-option {
            cursor: pointer;
            font-size: 13px;
            color: #333;
        }

        .multiselect-option:hover {
            background: #f5f5f5;
        }

        .multiselect-option label {
            color: #333;
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 100%;
            margin: 0;
            padding: 6px 10px;
        }

        .multiselect-option input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .multiselect-placeholder {
            color: #999;
        }

        .multiselect-count {
            color: #2c5f2d;
            font-weight: bold;
        }

        #table-container {
            background: white;
            max-height: 600px;
            overflow-y: auto;
            overflow-x: auto;
            scroll-behavior: smooth;
            border-radius: 0 0 12px 12px;
        }

        /* ========================================
           DATA TABLE
           ======================================== */

        #data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            table-layout: auto;
        }

        /* Desktop column widths with min-width */
        #data-table th:nth-child(1),
        #data-table td:nth-child(1) { min-width: 40px; }   /* No. */

        #data-table th:nth-child(2),
        #data-table td:nth-child(2) { min-width: 60px; }   /* First name translit */

        #data-table th:nth-child(3),
        #data-table td:nth-child(3) { min-width: 60px; }   /* Last name translit */

        #data-table th:nth-child(4),
        #data-table td:nth-child(4) { min-width: 60px; }   /* Patronymic translit */

        #data-table th:nth-child(5),
        #data-table td:nth-child(5) { min-width: 60px; }   /* First name native */

        #data-table th:nth-child(6),
        #data-table td:nth-child(6) { min-width: 60px; }   /* Last name native */

        #data-table th:nth-child(7),
        #data-table td:nth-child(7) { min-width: 60px; }   /* Patronymic native */

        #data-table th:nth-child(8),
        #data-table td:nth-child(8) { min-width: 70px; }  /* Ethnic and religious affiliation */

        #data-table th:nth-child(9),
        #data-table td:nth-child(9) { min-width: 40px; }   /* Sex */

        #data-table th:nth-child(10),
        #data-table td:nth-child(10) { min-width: 40px; }  /* Length */

        #data-table th:nth-child(11),
        #data-table td:nth-child(11) { min-width: 40px; }  /* Width */

        #data-table th:nth-child(12),
        #data-table td:nth-child(12) { min-width: 90px; }  /* Plan part */

        #data-table th:nth-child(13),
        #data-table td:nth-child(13) { min-width: 120px; } /* Note */

        /* Table Header */
        #data-table thead {
            position: sticky;
            top: 0;
            background: #2c5f2d;
            color: white;
            z-index: 10;
        }

        #data-table th {
            padding: 10px 8px;
            text-align: left;
            font-weight: bold;
            border-bottom: 2px solid #1a3a1b;
            cursor: pointer;
            user-select: none;
            position: relative;
            vertical-align: top;
            overflow-wrap: break-word;
        }

        #data-table th:hover {
            background: #3a7a3d;
        }

        /* Sort Indicators */
        #data-table th[data-sort]::after {
            content: '\00a0⇅';
            opacity: 0.3;
            font-size: 12px;
            margin-left: 5px;
            white-space: nowrap;
        }

        #data-table th.sort-asc::after {
            content: '\00a0▲';
            opacity: 1;
        }

        #data-table th.sort-desc::after {
            content: '\00a0▼';
            opacity: 1;
        }

        /* Table Cells */
        #data-table td {
            padding: 8px;
            border-bottom: 1px solid #e0e0e0;
            overflow-wrap: break-word;
            vertical-align: top;
        }

        /* Table Rows */
        #data-table tbody tr {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #data-table tbody tr:hover {
            background-color: #f0f8f0;
        }

        #data-table tbody tr.selected {
            background-color: #c8e6c9 !important;
            border-left: 4px solid #2c5f2d;
        }

        #data-table tbody tr.selected:hover {
            background-color: #b8d6b8 !important;
        }

        #data-table tbody tr:nth-child(even) {
            background-color: #fafafa;
        }

        #data-table tbody tr:nth-child(even):hover {
            background-color: #f0f8f0;
        }

        /* ========================================
           MAP OVERLAYS
           ======================================== */

        /* Plot Number Labels */
        /* Use higher specificity selector (element + 2 classes = 0,2,1) to override Leaflet's
           default .leaflet-marker-icon selector (1 class = 0,1,0) without !important */
        div.leaflet-marker-icon.field-label,
        div.leaflet-marker-icon.field-label-hidden {
            background: transparent;
            border: none;
            padding: 2px 4px;
            font-size: 12px;
            font-weight: bold;
            color: #555;
            text-align: center;
            pointer-events: none; /* Allow hover events to pass through to polygons below */
            transition: opacity 0.3s;
            white-space: nowrap;
            overflow: visible;
        }

        div.leaflet-marker-icon.field-label-hidden {
            opacity: 0;
        }

        div.leaflet-marker-icon.significance-marker {
            background: transparent;
            border: none;
            pointer-events: none;
            overflow: visible;
        }

        /* Street Name Labels */
        .leaflet-text-path {
            pointer-events: none;
        }

        .leaflet-text-path span {
            font-size: 16px;
            font-weight: bold;
            transition: opacity 0.3s;
            white-space: nowrap;
            color: #333;
            background-color: rgba(255, 255, 255, 0.75);
            padding: 1px 4px;
            border-radius: 2px;
            display: inline-block;
            position: absolute;
            transform: translate(-50%, -100%);
        }

        .leaflet-text-path-hidden span {
            opacity: 0 !important;
        }

        /* Popup Content */
        .leaflet-popup-content {
            margin: 10px;
            line-height: 1.4;
        }

        .popup-info {
            font-size: 13px;
            margin: 5px 0;
        }

        /* Map Legend */
        .legend {
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            line-height: 20px;
            font-size: 12px;
        }

        .legend-toggle-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #2c5f2d;
            color: white;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            font-size: 12px;
            user-select: none;
        }

        .legend-toggle-btn:hover {
            background: #3a7a3e;
        }

        .legend-toggle-btn.collapsed {
            border-radius: 5px;
        }

        .legend-arrow {
            font-size: 12px;
            transition: transform 0.3s;
        }

        .legend-toggle-btn.collapsed .legend-arrow {
            transform: rotate(-90deg);
        }

        .legend-content {
            max-height: 1000px;
            overflow: visible;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
        }

        .legend-content.collapsed {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .legend-content-inner {
            padding: 10px;
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .legend-item {
            margin: 3px 0;
        }

        .legend-color {
            display: inline-block;
            width: 20px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #333;
            vertical-align: middle;
        }

        /* Tablet legend styles */
        @media (max-width: 1024px) {
            .legend-toggle-btn {
                padding: 7px 10px;
                font-size: 11px;
            }

            .legend-content-inner {
                padding: 8px;
                font-size: 11px;
                line-height: 18px;
            }

            .legend-title {
                margin-bottom: 4px;
                font-size: 11px;
            }

            .legend-item {
                margin: 2px 0;
            }

            .legend-color {
                width: 16px;
                height: 12px;
                margin-right: 4px;
            }
        }

        /* Mobile legend styles */
        @media (max-width: 768px) {
            .legend-toggle-btn {
                padding: 6px 8px;
                font-size: 10px;
            }

            .legend-content-inner {
                padding: 6px;
                font-size: 10px;
                line-height: 16px;
            }

            .legend-title {
                margin-bottom: 3px;
                font-size: 10px;
            }

            .legend-item {
                margin: 2px 0;
            }

            .legend-color {
                width: 14px;
                height: 10px;
                margin-right: 3px;
            }
        }

        /* ========================================
           COLLAPSIBLE CONTROL PANEL
           ======================================== */

        .leaflet-control-panel {
            background: white;
            border-radius: 5px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            min-width: 200px;
        }

        .panel-toggle-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #2c5f2d;
            color: white;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            font-size: 12px;
            user-select: none;
        }

        .panel-toggle-btn:hover {
            background: #3a7a3e;
        }

        .panel-toggle-btn.collapsed {
            border-radius: 5px;
        }

        .panel-icon {
            font-size: 14px;
            margin-right: 6px;
        }

        .panel-arrow {
            font-size: 12px;
            transition: transform 0.3s;
        }

        .panel-toggle-btn.collapsed .panel-arrow {
            transform: rotate(-90deg);
        }

        .panel-content {
            max-height: 1000px;
            overflow: visible;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            opacity: 1;
        }

        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .panel-section {
            padding: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .panel-section:last-child {
            border-bottom: none;
        }

        .panel-section-title {
            font-weight: bold;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }

        /* Layer checkboxes */
        .layer-checkbox-label {
            display: flex;
            align-items: center;
            padding: 4px 0;
            cursor: pointer;
            font-size: 12px;
            color: #333;
        }

        .layer-checkbox-label input[type="checkbox"] {
            margin-right: 6px;
            cursor: pointer;
        }

        .layer-checkbox-label:hover {
            color: #2c5f2d;
        }

        /* ========================================
           MAP NAVIGATION STYLES
           ======================================== */

        .map-navigation-title {
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 12px;
            color: #333;
        }

        .map-navigation-buttons {
            display: flex;
            gap: 5px;
        }

        .map-nav-btn {
            flex: 1;
            padding: 6px 10px;
            background: #f4f4f4;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            transition: all 0.2s;
            color: #333;
            white-space: nowrap;
        }

        .map-nav-btn:hover {
            background: #2c5f2d;
            color: white;
            border-color: #2c5f2d;
        }

        .map-nav-btn.active {
            background: #2c5f2d;
            color: white;
            border-color: #2c5f2d;
        }

        /* Download section styles */
        .download-title-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            padding: 4px 0 8px 0;
            font-weight: bold;
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .download-title-wrapper:hover {
            color: #2c5f2d;
        }

        .download-title-arrow {
            font-size: 10px;
            color: #999;
            transition: transform 0.3s;
        }

        .download-title-arrow.collapsed {
            transform: rotate(-90deg);
        }

        .download-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 200px;
            overflow: hidden;
            opacity: 1;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin 0.3s ease-out;
            margin-bottom: 4px;
        }

        .download-buttons-container.collapsed {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
        }

        .download-plan-btn {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f4f4f4;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #333;
            transition: all 0.2s;
            width: 100%;
        }

        .download-plan-btn:hover {
            background: #2c5f2d;
            color: white;
            border-color: #2c5f2d;
        }

        .download-plan-btn:hover .download-plan-info {
            color: rgba(255, 255, 255, 0.8);
        }

        .download-plan-btn:active {
            transform: scale(0.98);
        }

        .download-plan-info {
            font-size: 11px;
            color: #999;
            transition: color 0.2s;
        }

        .download-all-btn {
            background: #e8f5e9;
            border-color: #2c5f2d;
            font-weight: 500;
        }

        .download-all-btn:hover {
            background: #2c5f2d;
            color: white;
        }

        /* Tablet control panel styles */
        @media (max-width: 1024px) {
            .leaflet-control-panel {
                min-width: 180px;
            }

            .panel-toggle-btn {
                padding: 7px 10px;
                font-size: 11px;
            }

            .panel-section {
                padding: 8px;
            }

            .panel-section-title {
                font-size: 10px;
                margin-bottom: 5px;
            }

            .layer-checkbox-label {
                font-size: 11px;
            }

            .map-navigation-title {
                font-size: 11px;
                margin-bottom: 6px;
            }

            .map-nav-btn {
                padding: 5px 8px;
                font-size: 10px;
            }

            .download-title-wrapper {
                font-size: 10px;
                padding: 3px 0 6px 0;
            }

            .download-plan-btn {
                padding: 7px 10px;
                font-size: 11px;
            }

            .download-plan-info {
                font-size: 10px;
            }
        }

        /* Mobile control panel styles */
        @media (max-width: 768px) {
            .leaflet-control-panel {
                min-width: 160px;
            }

            .panel-toggle-btn {
                padding: 6px 8px;
                font-size: 10px;
            }

            .panel-section {
                padding: 6px;
            }

            .panel-section-title {
                font-size: 9px;
                margin-bottom: 4px;
            }

            .layer-checkbox-label {
                font-size: 10px;
            }

            .map-navigation-title {
                font-size: 10px;
                margin-bottom: 5px;
            }

            .map-nav-btn {
                padding: 4px 6px;
                font-size: 9px;
            }

            .download-title-wrapper {
                font-size: 9px;
                padding: 3px 0 5px 0;
            }

            .download-plan-btn {
                padding: 6px 8px;
                font-size: 10px;
            }

            .download-plan-info {
                font-size: 9px;
            }
        }

        /* ========================================
           LEAFLET LAYER CONTROL (RESPONSIVE)
           ======================================== */

        /* Tablet layer control styles */
        @media (max-width: 1024px) {
            .leaflet-control-layers {
                font-size: 11px;
            }

            .leaflet-control-layers-toggle {
                width: 32px;
                height: 32px;
            }

            .leaflet-control-layers-expanded {
                padding: 6px 8px;
            }

            .leaflet-control-layers label {
                font-size: 11px;
                line-height: 1.4;
            }
        }

        /* Mobile layer control styles */
        @media (max-width: 768px) {
            .leaflet-control-layers {
                font-size: 10px;
            }

            .leaflet-control-layers-toggle {
                width: 28px;
                height: 28px;
            }

            .leaflet-control-layers-expanded {
                padding: 5px 6px;
            }

            .leaflet-control-layers label {
                font-size: 10px;
                line-height: 1.3;
            }

            .leaflet-control-layers input {
                transform: scale(0.9);
            }
        }

        /* ========================================
           LEAFLET SCALE CONTROL (RESPONSIVE)
           ======================================== */

        /* Tablet scale control styles */
        @media (max-width: 1024px) {
            .leaflet-control-scale {
                font-size: 10px;
            }

            .leaflet-control-scale-line {
                padding: 1px 4px;
            }
        }

        /* Mobile scale control styles */
        @media (max-width: 768px) {
            .leaflet-control-scale {
                font-size: 9px;
            }

            .leaflet-control-scale-line {
                padding: 1px 3px;
            }
        }

        /* ========================================
           LEAFLET ZOOM CONTROL (RESPONSIVE)
           ======================================== */

        /* Tablet zoom control styles */
        @media (max-width: 1024px) {
            .leaflet-control-zoom a {
                width: 28px;
                height: 28px;
                line-height: 28px;
                font-size: 16px;
            }
        }

        /* Mobile zoom control styles */
        @media (max-width: 768px) {
            .leaflet-control-zoom a {
                width: 26px;
                height: 26px;
                line-height: 26px;
                font-size: 14px;
            }
        }

        /* ========================================
           LOADING STATE
           ======================================== */

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 9999;
        }

        /* ========================================
           SCROLL TO MAP BUTTON
           ======================================== */

        #scroll-to-map {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.5);
            color: #2c5f2d;
            border: 1px solid rgba(44, 95, 45, 0.3);
            border-radius: 30px;
            padding: 8px 14px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s, background 0.2s, transform 0.2s;
            white-space: nowrap;
            backdrop-filter: blur(6px);
        }

        #scroll-to-map.show {
            opacity: 1;
            visibility: visible;
        }

        #scroll-to-map:hover {
            background: rgba(255, 255, 255, 0.75);
            border-color: rgba(44, 95, 45, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }

        #scroll-to-map:active {
            transform: translateY(0);
        }

        #scroll-to-map-arrow {
            font-size: 16px;
            line-height: 1;
        }

        /* Mobile adjustments */
        @media (max-width: 768px) {
            #scroll-to-map {
                bottom: 15px;
                right: 15px;
                padding: 7px 12px;
                font-size: 11px;
            }

            #scroll-to-map-arrow {
                font-size: 14px;
            }
        }

        /* ========================================
           FOOTER
           ======================================== */

        footer {
            background: #2c5f2d;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 13px;
            width: 100%;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
            margin-top: 30px;
        }

        footer a {
            color: #90EE90;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .footer-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .footer-section {
            flex: 1;
            min-width: 250px;
        }

        /* ========================================
           RESPONSIVE DESIGN
           ======================================== */

        /* Medium screens - reduce font size */
        @media (max-width: 1200px) {
            #data-table {
                font-size: 12px;
            }
        }

        @media (max-width: 800px) {
            #data-table {
                font-size: 11px;
            }
        }

        @media (max-width: 600px) {
            #data-table {
                font-size: 10px;
            }
        }

        /* Tablets */
        @media (max-width: 1024px) {
            #page-header {
                padding: 25px 30px;
            }

            #page-title {
                font-size: 24px;
            }

            #page-description {
                font-size: 15px;
            }

            #container {
                padding: 0 15px;
                margin: 20px auto;
            }

            #map {
                height: 500px;
            }

            #table-header-top {
                padding: 10px 20px;
            }

            #table-title {
                font-size: 17px;
            }

            #filters-content {
                padding: 18px 20px;
            }

        }

        /* Mobile */
        @media (max-width: 768px) {
            #page-header {
                padding: 20px 15px;
            }

            #page-title {
                font-size: 20px;
            }

            #page-description {
                font-size: 14px;
                padding: 12px;
            }

            #container {
                padding: 0 10px;
                margin: 15px auto;
            }

            #map {
                height: 400px;
            }

            #table-header-top {
                padding: 10px 20px;
            }

            #table-title {
                font-size: 16px;
            }

            #table-header-controls {
                gap: 6px;
            }

            #csv-download-toggle {
                padding: 5px 10px;
                font-size: 12px;
            }

            .download-menu {
                min-width: 180px;
            }

            .download-menu-item {
                padding: 8px 12px;
                font-size: 12px;
            }

            #filters-toggle {
                padding: 5px 10px;
            }

            #filters-toggle-text {
                font-size: 12px;
            }

            #filters-content {
                padding: 15px 20px;
            }

            #table-container {
                max-height: 400px;
            }

            footer {
                padding: 15px 10px;
                font-size: 11px;
            }

            .footer-content {
                flex-direction: column;
                gap: 8px;
            }

            .footer-section {
                min-width: 100%;
                text-align: center;
            }

            .filters-row {
                flex-direction: column;
            }

            .filter-group {
                width: 100%;
            }

            /* Mobile - reduce padding */
            #data-table th {
                padding: 6px 4px;
            }

            #data-table td {
                padding: 6px 4px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Map loading...</div>

    <!-- Scroll to Map Button -->
    <button id="scroll-to-map" title="Back to map">
        <span id="scroll-to-map-arrow">↑</span>
        <span>Back to Map</span>
    </button>

    <header id="page-header">
        <h1 id="page-title">Mapping for local history projects: from archival document to user model</h1>
        <h2 id="page-subtitle">Plans for the restoration of Radashkovichy after the fires of 1888 and 1891: indicating land plots and owners</h2>
    </header>

    <div id="page-description">
        <div class="user-guide-intro">
            <p>Project description will be added here.</p>
        </div>

        <div class="user-guide-content">
            <div class="guide-column">
                <h4>Interactive Map</h4>
                <p>Navigate the map by clicking and dragging to move around, or use the scroll wheel and +/− buttons in the top-left corner to zoom.</p>
                <p>Click any land plot to view its details: householder's name and dimensions. The data table below automatically scrolls to the corresponding record.</p>
                <p>The control in the top-right corner lets you toggle different layers:</p>
                <ul>
                    <li><strong>Land plots</strong> from the 1888 and 1891 restoration plans</li>
                    <li><strong>Color overlays</strong> visualizing ethnic and religious affiliation</li>
                    <li><strong>Pattern overlays</strong> showing plot distribution by sex</li>
                </ul>
                <p>These visual overlays help you analyze how land was distributed among different groups.</p>
                <p>The restoration plans can also be downloaded as GeoJSON files from the same menu for use in GIS software.</p>
            </div>

            <div class="guide-column">
                <h4>Data Table</h4>
                <p>The table displays all land plots with their associated records. Clicking a row highlights the corresponding plot on the map.</p>
                <p>Press the <strong>Filters</strong> button to expand the search and filter panel. The search field matches text across all columns. Filters let you narrow results by householder name, religion, sex, and more. Combine them freely.</p>
                <p>Click any column header to sort; click again to reverse the order.</p>
                <p>The download button exports CSV files compatible with any spreadsheet application. You can choose to download either filtered records or the complete dataset.</p>
            </div>
        </div>
    </div>

    <div id="container">
        <div id="map-section">
            <div id="map"></div>
        </div>

        <div id="table-section">
            <div id="table-header">
                <div id="table-header-top">
                    <h2 id="table-title">Land Plots</h2>
                    <div id="table-header-controls">
                        <div id="csv-download">
                            <div id="csv-download-toggle">
                                <span>Download CSV</span>
                            </div>
                            <div id="csv-download-menu" class="download-menu">
                                <div class="download-menu-item" data-csv-type="all">Download all data</div>
                                <div class="download-menu-item" data-csv-type="filtered" id="csv-filtered-option" style="display: none;">Download filtered data (<span id="csv-filtered-count">0</span> records)</div>
                            </div>
                        </div>
                        <div id="filters-toggle">
                            <span id="filters-toggle-text">
                                Filters
                                <span id="filters-active-badge"></span>
                            </span>
                            <span id="filters-toggle-icon" class="collapsed">▼</span>
                        </div>
                    </div>
                </div>

                <div id="filters-content" class="collapsed">
                    <div class="filter-wrapper" id="search-wrapper">
                        <input type="text" id="search-input" placeholder="Find anything in the table">
                        <button class="clear-filter" id="clear-search" title="Clear search">×</button>
                    </div>

                    <div class="filters-row">
                        <div class="filter-group">
                            <label class="filter-label">Owner Name:</label>
                            <div class="filter-wrapper" id="owner-filter-wrapper">
                                <input type="text" id="filter-owner" class="filter-input" placeholder="Filter by owner...">
                                <button class="clear-filter" id="clear-owner" title="Clear filter">×</button>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Ethnic and religious affiliation:</label>
                            <div class="filter-wrapper">
                                <div class="multiselect-dropdown" id="religion-multiselect">
                                    <div class="multiselect-selected">
                                        <span class="multiselect-placeholder">Select Religion...</span>
                                    </div>
                                    <div class="multiselect-options"></div>
                                </div>
                                <button class="clear-filter" id="clear-religion" title="Clear selection" style="display: none;">×</button>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Sex:</label>
                            <div class="filter-wrapper">
                                <div class="multiselect-dropdown" id="sex-multiselect">
                                    <div class="multiselect-selected">
                                        <span class="multiselect-placeholder">Select Sex...</span>
                                    </div>
                                    <div class="multiselect-options"></div>
                                </div>
                                <button class="clear-filter" id="clear-sex" title="Clear selection" style="display: none;">×</button>
                            </div>
                        </div>
                    </div>

                    <div class="filters-row">
                        <div class="filter-group">
                            <label class="filter-label">Plan:</label>
                            <select id="filter-map" class="filter-select" style="padding: 6px 8px;">
                                <option value="">All Plans</option>
                                <option value="map1">Restoration plan 1888</option>
                                <option value="map2">Restoration plan 1891</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label class="filter-label">Plan Part:</label>
                            <div class="filter-wrapper">
                                <div class="multiselect-dropdown" id="planpart-multiselect">
                                    <div class="multiselect-selected">
                                        <span class="multiselect-placeholder">Select Plan Parts...</span>
                                    </div>
                                    <div class="multiselect-options"></div>
                                </div>
                                <button class="clear-filter" id="clear-planpart" title="Clear selection" style="display: none;">×</button>
                            </div>
                        </div>
                    </div>

                    <div id="clear-all-filters-wrapper">
                        <button id="clear-all-filters">Clear all filters</button>
                    </div>
                </div>
            </div>

            <div id="table-container">
                <table id="data-table">
                    <thead>
                        <tr>
                            <th data-sort="number">No.</th>
                            <th data-sort="firstnametranslit">First name<br>translit</th>
                            <th data-sort="lastnametranslit">Last name<br>translit</th>
                            <th data-sort="patronymictranslit">Patronymic<br>translit</th>
                            <th data-sort="firstnamenative">First name<br>native</th>
                            <th data-sort="lastnamenative">Last name<br>native</th>
                            <th data-sort="patronymicnative">Patronymic<br>native</th>
                            <th data-sort="religion">Ethnic and religious affiliation</th>
                            <th data-sort="sex">Sex</th>
                            <th data-sort="length">Length</th>
                            <th data-sort="width">Width</th>
                            <th data-sort="planpart">Plan part</th>
                            <th data-sort="note">Note</th>
                        </tr>
                    </thead>
                    <tbody id="data-table-body">
                        <!-- Data will be loaded via JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <!-- Leaflet JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet Gesture Handling Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-gesture-handling@1.2.2/dist/leaflet-gesture-handling.min.js"
            crossorigin=""></script>

    <!-- Leaflet TextPath Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet-textpath@1.2.3/leaflet.textpath.min.js"></script>

    <!-- JSZip for creating ZIP archives -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
            integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg=="
            crossorigin="anonymous"></script>

    <script>
        // ========================================
        // APPLICATION INITIALIZATION
        // ========================================

        window.addEventListener('load', function() {
            // Hide loading indicator
            document.getElementById('loading').style.display = 'none';

            // Check if Leaflet is loaded
            if (typeof L === 'undefined') {
                alert('Error: The library Leaflet was not loaded. Check your internet connection.');
                return;
            }

            // ========================================
            // MAP CONFIGURATION
            // ========================================

            const mapCenter = [54.159000, 27.237500]; // Center between both maps
            const initialZoom = 15;
            const minZoomForLabels = 18; // Minimum zoom level to show labels
            
            // ========================================
            // MAP INITIALIZATION
            // ========================================

            const map = L.map('map', {
                gestureHandling: true,
                gestureHandlingOptions: {
                    text: {
                        touch: "Use two fingers to move the map",
                        scroll: "Use Ctrl + scroll to zoom the map",
                        scrollMac: "Use ⌘ + scroll to zoom the map"
                    }
                }
            }).setView(mapCenter, initialZoom);

            // OpenStreetMap base layer
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
                maxZoom: 22,
                maxNativeZoom: 19
            }).addTo(map);

            // ========================================
            // POPUP CONTENT GENERATION
            // ========================================

            // Create popup content for land plots
            function createPopupContent(props, sourceLayer) {
                let popupContent = '';
                let hasData = false;

                // Determine field names based on source layer
                const isMap2 = sourceLayer === 'plan_1891_plots';
                const lengthField = isMap2 ? 'Length of plot' : 'Length of plots';
                const widthField = isMap2 ? 'Width of plot' : 'Width of plots';

                // Field Number
                if (props['Field number']) {
                    popupContent += `<div class="popup-info"><b>Field Number:</b> ${props['Field number']}</div>`;
                    hasData = true;
                }

                // Owner Name (translit) - first
                if (props['Name translit']) {
                    popupContent += `<div class="popup-info"><b>Name:</b> ${props['Name translit']}</div>`;
                    hasData = true;
                }

                // Owner Name (native) - second
                if (props['Name native']) {
                    popupContent += `<div class="popup-info"><b>Name original:</b> ${props['Name native']}</div>`;
                    hasData = true;
                }

                // Length
                const lengthValue = props[lengthField];
                if (lengthValue && lengthValue !== null && lengthValue !== '' && String(lengthValue).trim() !== '') {
                    popupContent += `<div class="popup-info"><b>Length:</b> ${lengthValue} sazhens</div>`;
                    hasData = true;
                }

                // Width
                const widthValue = props[widthField];
                if (widthValue && widthValue !== null && widthValue !== '' && String(widthValue).trim() !== '') {
                    popupContent += `<div class="popup-info"><b>Width:</b> ${widthValue} sazhens</div>`;
                    hasData = true;
                }

                return hasData ? popupContent : null;
            }

            // ========================================
            // POPUP AND INTERACTION HELPERS
            // ========================================

            /**
             * Setup popup event handlers for land plot layers
             * Handles table row synchronization and style changes on popup open/close
             *
             * @param {L.Layer} layer - The Leaflet layer to attach events to
             * @param {L.GeoJSON} parentLayer - The parent GeoJSON layer (for resetStyle)
             * @param {Object} props - Feature properties (for table row matching)
             * @param {Object} feature - The GeoJSON feature (for restoring original style)
             */
            function setupPopupEventHandlers(layer, parentLayer, props, feature) {
                // Store previous colors to restore after popup closes
                let previousFillColor;
                let previousBorderColor;
                let previousLabelColor;

                layer.on('popupopen', function() {
                    // Save current colors before changing
                    const currentStyle = layer.options;
                    previousFillColor = currentStyle.fillColor;
                    previousBorderColor = currentStyle.color;

                    // Save current label color
                    if (layer._fieldNumberMarker) {
                        const markerElement = layer._fieldNumberMarker.getElement();
                        if (markerElement) {
                            previousLabelColor = markerElement.style.color || '#333';
                        }
                    }

                    // Change to orange highlight with #555 border and label
                    layer.setStyle({weight: 2, fillColor: '#f7f786', color: '#555'});

                    // Update pattern color if sex layer is active
                    if (typeof updatePatternColor === 'function') {
                        updatePatternColor(layer, '#555');
                    }

                    // Change field number color to #555
                    if (layer._fieldNumberMarker) {
                        const markerElement = layer._fieldNumberMarker.getElement();
                        if (markerElement) {
                            markerElement.style.color = '#555';
                        }
                    }

                    // Highlight corresponding row in table
                    document.querySelectorAll('#data-table tbody tr.selected').forEach(row => {
                        row.classList.remove('selected');
                    });
                    document.querySelectorAll('#data-table tbody tr').forEach(row => {
                        if (row.dataset.fid == props.fid && row.dataset.sourceLayer == props.source_layer) {
                            row.classList.add('selected');
                            // Scroll row to top only if clicked on map (not from table)
                            if (!openedFromTableClick) {
                                scrollRowIntoView(row);
                            }
                        }
                    });
                });

                // Add event listener for when popup closes
                layer.on('popupclose', function() {
                    // Clear table row selection
                    document.querySelectorAll('#data-table tbody tr.selected').forEach(row => {
                        row.classList.remove('selected');
                    });

                    // Restore previous colors and original border weight
                    const originalStyle = getFeatureStyle(feature);
                    layer.setStyle({
                        weight: originalStyle.weight,
                        fillColor: previousFillColor,
                        color: previousBorderColor
                    });

                    // Update pattern color if sex layer is active
                    if (typeof updatePatternColor === 'function') {
                        updatePatternColor(layer, previousBorderColor);
                    }

                    // Restore field number color
                    if (layer._fieldNumberMarker) {
                        const markerElement = layer._fieldNumberMarker.getElement();
                        if (markerElement) {
                            markerElement.style.color = previousLabelColor;
                        }
                    }
                });
            }

            /**
             * Setup hover effects for land plot layers
             * Increases weight and opacity on mouseover, resets on mouseout
             *
             * @param {L.Layer} layer - The Leaflet layer
             * @param {L.GeoJSON} parentLayer - Parent layer (unused, kept for compatibility)
             * @param {Object} feature - The GeoJSON feature (for restoring original style)
             */
            function setupHoverEffects(layer, parentLayer, feature) {
                layer.on('mouseover', function() {
                    if (!layer.getPopup() || !layer.getPopup().isOpen()) {
                        layer.setStyle({weight: 2});
                    }
                });
                layer.on('mouseout', function() {
                    if (!layer.getPopup() || !layer.getPopup().isOpen()) {
                        const originalStyle = getFeatureStyle(feature);
                        layer.setStyle({weight: originalStyle.weight});
                    }
                });
            }

            /**
             * Create field number marker with click handler
             * Creates a marker at the polygon center that opens the parent polygon's popup
             *
             * @param {L.Layer} layer - The polygon layer
             * @param {Object} props - Feature properties (contains 'Field number')
             * @param {L.LayerGroup} labelGroup - Target marker group to add marker to
             * @param {number} minZoomForLabels - Zoom threshold for label visibility
             * @param {L.Map} map - Leaflet map instance
             * @returns {L.Marker|null} The created marker or null if no field number
             */
            function createFieldNumberMarker(layer, props, labelGroup, minZoomForLabels, map) {
                if (!props['Field number']) {
                    return null;
                }

                const center = layer.getBounds().getCenter();

                // Check current zoom to set initial visibility
                const currentZoom = map.getZoom();
                const initialClass = currentZoom >= minZoomForLabels ? 'field-label' : 'field-label field-label-hidden';

                const marker = L.marker(center, {
                    icon: L.divIcon({
                        className: initialClass,
                        html: props['Field number'],
                        iconSize: [30, 20],
                        iconAnchor: [15, 10]
                    }),
                    bubblingMouseEvents: false
                });

                // Click on marker opens popup from parent polygon
                marker.on('click', function(e) {
                    if (layer.getPopup()) {
                        layer.openPopup(e.latlng);
                    }
                });

                // Add marker to label group
                labelGroup.addLayer(marker);

                // Store reference to marker in layer for later access (e.g., for styling based on religion)
                layer._fieldNumberMarker = marker;

                return marker;
            }

            /**
             * Setup building click-through to underlying plot
             * Makes buildings/subdivisions transparent to clicks - opens the underlying plot's popup
             *
             * @param {L.Layer} layer - The building/subdivision layer
             * @param {L.GeoJSON} parentLayer - Layer to search for underlying plots
             * @param {string} plotSourceLayerName - Source layer identifier for plots (e.g., 'plan_1888_plots')
             */
            function setupBuildingClickThrough(layer, parentLayer, plotSourceLayerName) {
                layer.on('click', function(e) {
                    const clickedPoint = e.latlng;

                    // Find land plot under the clicked point
                    parentLayer.eachLayer(function(l) {
                        if (l.feature &&
                            l.feature.properties.source_layer === plotSourceLayerName &&
                            l.getBounds &&
                            l.getBounds().contains(clickedPoint)) {

                            if (l.getPopup()) {
                                l.openPopup(clickedPoint);
                            }
                        }
                    });
                });
            }

            // ========================================
            // PATTERN MANAGEMENT (defined early for use in event handlers)
            // ========================================

            /**
             * Update pattern color for a specific layer
             * Used when border color changes (click, religion layer toggle)
             */
            function updatePatternColor(layer, newColor) {
                if (!layer._sexPattern || !layer._patternPath) return;

                // Create new pattern with updated color
                let patternId;
                if (layer._sexPattern === 'male') {
                    patternId = createMalePattern(newColor);
                } else if (layer._sexPattern === 'female') {
                    patternId = createFemalePattern(newColor);
                }

                // Apply new pattern to the overlay path
                if (patternId) {
                    layer._patternPath.setAttribute('fill', `url(#${patternId})`);
                    layer._patternId = patternId;
                }
            }

            // Placeholder for pattern creation functions (will be defined later)
            let createMalePattern, createFemalePattern;

            // ========================================
            // LAYER STYLING FUNCTIONS
            // ========================================

            // Determine feature style based on source layer
            function getFeatureStyle(feature) {
                const sourceLayer = feature.properties.source_layer;
                const props = feature.properties;

                // Plan 1888 - Land plots
                if (sourceLayer === 'plan_1888_plots') {
                    return {
                        fillColor: props.fill_color || '#78c679',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#555',
                        weight: props.stroke_width || 1,
                        opacity: 1
                    };
                }

                // Plan 1888 - Plot subdivisions
                if (sourceLayer === 'plan_1888_plot_subdivisions') {
                    return {
                        fillColor: props.fill_color || '#c2e699',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#78c679',
                        weight: props.stroke_width || 1,
                        opacity: 1
                    };
                }

                // Plan 1888 - Buildings
                if (sourceLayer === 'plan_1888_buildings') {
                    return {
                        fillColor: props.fill_color || '#ffffcc',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#e6e6b3',
                        weight: props.stroke_width || 1,
                        opacity: 1
                    };
                }

                // Plan 1891 - Land plots
                if (sourceLayer === 'plan_1891_plots') {
                    return {
                        fillColor: props.fill_color || '#78c679',
                        fillOpacity: props.fill_opacity || 0.8,
                        color: props.stroke_color || '#555',
                        weight: props.stroke_width || 1,
                        opacity: 1
                    };
                }

                // Default style
                return {
                    fillColor: '#cccccc',
                    fillOpacity: 0.5,
                    color: '#666666',
                    weight: 2,
                    opacity: 1
                };
            }

            // ========================================
            // GLOBAL LAYER VARIABLES
            // ========================================

            let combinedLayer; // Combined GeoJSON layer with all features (deprecated - use plotsLayer)
            let plotsLayer; // Plan 1888 land plots layer (interactive)
            let subdivisionsLayer; // Plan 1888 plot subdivisions layer (non-interactive)
            let buildingsLayer; // Plan 1888 buildings layer (non-interactive)
            let map2Layer; // Map 2 GeoJSON layer
            let fieldLabelsGroup = L.layerGroup(); // Group for plot number markers for map1
            let map2LabelsGroup = L.layerGroup(); // Group for plot number markers for map2
            let streetLabelsGroup = L.layerGroup(); // Group for street/square name labels for map1
            let map2StreetLabelsGroup = L.layerGroup(); // Group for street/square name labels for map2

            // ========================================
            // DATA LOADING
            // ========================================

            // Load all GeoJSON files in parallel
            Promise.all([
                fetch('data/plan_1888_plots.geojson').then(r => {
                    if (!r.ok) throw new Error(`Failed to load plan_1888_plots.geojson: ${r.status}`);
                    return r.json();
                }),
                fetch('data/plan_1888_plot_subdivisions.geojson').then(r => {
                    if (!r.ok) throw new Error(`Failed to load plan_1888_plot_subdivisions.geojson: ${r.status}`);
                    return r.json();
                }),
                fetch('data/plan_1888_buildings.geojson').then(r => {
                    if (!r.ok) throw new Error(`Failed to load plan_1888_buildings.geojson: ${r.status}`);
                    return r.json();
                }),
                fetch('data/plan_1888_labels.geojson').then(r => {
                    if (!r.ok) throw new Error(`Failed to load plan_1888_labels.geojson: ${r.status}`);
                    return r.json();
                }),
                fetch('data/plan_1891_plots.geojson').then(r => {
                    if (!r.ok) throw new Error(`Failed to load plan_1891_plots.geojson: ${r.status}`);
                    return r.json();
                }),
                fetch('data/plan_1891_labels.geojson').then(r => {
                    if (!r.ok) throw new Error(`Failed to load plan_1891_labels.geojson: ${r.status}`);
                    return r.json();
                })
            ])
            .then(([plan1888PlotsData, plan1888SubdivisionsData, plan1888BuildingsData, plan1888LabelsData, plan1891PlotsData, plan1891LabelsData]) => {
                // Tag each feature with its source layer for proper styling
                plan1888PlotsData.features.forEach(f => f.properties.source_layer = 'plan_1888_plots');
                plan1888SubdivisionsData.features.forEach(f => f.properties.source_layer = 'plan_1888_plot_subdivisions');
                plan1888BuildingsData.features.forEach(f => f.properties.source_layer = 'plan_1888_buildings');
                plan1891PlotsData.features.forEach(f => f.properties.source_layer = 'plan_1891_plots');

                // Combine all Plan 1888 features for table data (used by saveTableData function)
                const allFeatures = [
                    ...plan1888PlotsData.features,
                    ...plan1888SubdivisionsData.features,
                    ...plan1888BuildingsData.features
                ];

                // ========================================
                // CREATE SEPARATE LAYERS FOR PROPER INTERACTION
                // ========================================

                // Layer 1: Land plots (interactive - bottom layer)
                plotsLayer = L.geoJSON(plan1888PlotsData, {
                    style: getFeatureStyle,
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        const sourceLayer = props.source_layer;

                        // Configure popups and interactions for land plots
                        // Create popup content using shared function
                        const popupContent = createPopupContent(props, sourceLayer);

                        // Bind popup only if there is data
                        if (popupContent) {
                            layer.bindPopup(popupContent);
                            setupPopupEventHandlers(layer, plotsLayer, props, feature);
                        }

                        // Create plot number marker with click handler
                        createFieldNumberMarker(layer, props, fieldLabelsGroup, minZoomForLabels, map);

                        // Setup hover effects
                        setupHoverEffects(layer, plotsLayer, feature);
                    }
                }).addTo(map);

                // Layer 2: Plot subdivisions (non-interactive - middle layer)
                subdivisionsLayer = L.geoJSON(plan1888SubdivisionsData, {
                    style: getFeatureStyle,
                    interactive: false  // Events pass through to plots below
                }).addTo(map);

                // Layer 3: Buildings (non-interactive - top layer)
                buildingsLayer = L.geoJSON(plan1888BuildingsData, {
                    style: getFeatureStyle,
                    interactive: false  // Events pass through to plots below
                }).addTo(map);

                // For backward compatibility, keep combinedLayer reference pointing to plotsLayer
                combinedLayer = plotsLayer;

                // ========================================
                // CREATE STREET/SQUARE LABELS FOR MAP 1 (Plan 1888)
                // ========================================

                plan1888LabelsData.features.forEach(feature => {
                    const props = feature.properties;
                    const coords = feature.geometry.coordinates;

                    // Use Label field for display
                    const labelText = props['Label'];

                    if (labelText) {
                        // Check current zoom to set initial visibility
                        const currentZoom = map.getZoom();
                        const initialClass = currentZoom >= minZoomForLabels ? 'leaflet-text-path' : 'leaflet-text-path leaflet-text-path-hidden';

                        const marker = L.marker([coords[1], coords[0]], {
                            icon: L.divIcon({
                                className: initialClass,
                                html: `<span style="display: inline-block;">${labelText}</span>`,
                                iconSize: [1, 1]
                            }),
                            interactive: false
                        });

                        streetLabelsGroup.addLayer(marker);
                    }
                });

                // ========================================
                // CREATE MAP 2 LAYER (Plan 1891)
                // ========================================

                map2Layer = L.geoJSON(plan1891PlotsData, {
                    style: getFeatureStyle,
                    onEachFeature: function(feature, layer) {
                        const props = feature.properties;
                        const sourceLayer = props.source_layer;

                        // Configure popups and interactions for plan 1891 land plots
                        if (sourceLayer === 'plan_1891_plots') {
                            // Create popup content using shared function
                            const popupContent = createPopupContent(props, sourceLayer);

                            // Bind popup only if there is data
                            if (popupContent) {
                                layer.bindPopup(popupContent);
                                setupPopupEventHandlers(layer, map2Layer, props, feature);
                            }

                            // Create plot number marker with click handler
                            createFieldNumberMarker(layer, props, map2LabelsGroup, minZoomForLabels, map);

                            // Setup hover effects
                            setupHoverEffects(layer, map2Layer, feature);
                        }
                    }
                });

                // ========================================
                // CREATE STREET/SQUARE LABELS FOR MAP 2 (Plan 1891)
                // ========================================

                plan1891LabelsData.features.forEach(feature => {
                    const props = feature.properties;
                    const coords = feature.geometry.coordinates;

                    // Use Label field for display
                    const labelText = props['Label'];

                    if (labelText) {
                        // Check current zoom to set initial visibility
                        const currentZoom = map.getZoom();
                        const initialClass = currentZoom >= minZoomForLabels ? 'leaflet-text-path' : 'leaflet-text-path leaflet-text-path-hidden';

                        const marker = L.marker([coords[1], coords[0]], {
                            icon: L.divIcon({
                                className: initialClass,
                                html: `<span style="display: inline-block;">${labelText}</span>`,
                                iconSize: [1, 1]
                            }),
                            interactive: false
                        });

                        map2StreetLabelsGroup.addLayer(marker);
                    }
                });

                // Create group combining historical map layers, plot numbers, and street labels
                // Order: plots (bottom), subdivisions (middle), buildings (top), then labels
                const historicalMapGroup = L.layerGroup([plotsLayer, subdivisionsLayer, buildingsLayer, fieldLabelsGroup, streetLabelsGroup]).addTo(map);
                const map2Group = L.layerGroup([map2Layer, map2LabelsGroup, map2StreetLabelsGroup]).addTo(map);

                // ========================================
                // ETHNIC AND RELIGIOUS AFFILIATION LAYER
                // ========================================

                // Create layer for ethnic and religious affiliation highlighting
                const ethnicReligiousLayer = L.layerGroup();

                // Color mapping for religious affiliation
                // Each religion has colors for: plot fill, border, label, subdivision, building
                const RELIGION_COLORS = {
                    'Christians': {
                        plot: '#93d14a',
                        border: '#333',
                        label: '#333',
                        subdivision: null,  // use default
                        building: null      // use default
                    },
                    'Jews': {
                        plot: '#7b3294',
                        border: '#ffffff',
                        label: '#ffffff',
                        subdivision: null,  // use default
                        building: null      // use default
                    },
                    'No data': {
                        plot: '#edf8fb',
                        border: '#333',
                        label: '#333',
                        subdivision: null,
                        building: null
                    },
                    'public property': {
                        plot: '#edf8fb',
                        border: '#333',
                        label: '#333',
                        subdivision: null,
                        building: null
                    }
                };

                // Default colors for other values
                const DEFAULT_RELIGION_COLORS = {
                    plot: '#ffcaca',
                    border: '#333',
                    label: '#333',
                    subdivision: null,
                    building: null
                };

                /**
                 * Apply religious affiliation coloring to all layers
                 */
                function applyReligionColoring() {
                    // Helper function to colorize plot layers
                    const colorizePlots = (layer) => {
                        if (!layer) return;

                        layer.eachLayer((l) => {
                            if (l.feature && l.feature.properties) {
                                const religion = l.feature.properties.Religion;
                                const colors = RELIGION_COLORS[religion] || DEFAULT_RELIGION_COLORS;

                                // Apply plot colors
                                if (l.setStyle) {
                                    l.setStyle({
                                        fillColor: colors.plot,
                                        color: colors.border
                                    });
                                }

                                // Change field number color
                                if (l._fieldNumberMarker) {
                                    const markerElement = l._fieldNumberMarker.getElement();
                                    if (markerElement) {
                                        markerElement.style.color = colors.label;
                                    }
                                }

                                // Update pattern color if sex layer is active
                                if (typeof updatePatternColor === 'function') {
                                    updatePatternColor(l, colors.border);
                                }

                                // Store religion colors on layer for later restoration
                                l._religionColors = colors;
                            }
                        });
                    };

                    // Apply colors only to visible plan layers
                    if (map.hasLayer(historicalMapGroup)) {
                        colorizePlots(plotsLayer);
                    }
                    if (map.hasLayer(map2Group)) {
                        colorizePlots(map2Layer);
                    }
                }

                /**
                 * Restore original colors to all layers
                 */
                function restoreOriginalColors() {
                    // Helper function to restore colors for a layer
                    const restorePlots = (layer) => {
                        if (!layer) return;

                        layer.eachLayer((l) => {
                            if (l.feature && l.setStyle) {
                                const originalStyle = getFeatureStyle(l.feature);
                                l.setStyle({
                                    fillColor: originalStyle.fillColor,
                                    color: originalStyle.color
                                });

                                // Restore field number color to original (#333)
                                if (l._fieldNumberMarker) {
                                    const markerElement = l._fieldNumberMarker.getElement();
                                    if (markerElement) {
                                        markerElement.style.color = '#333';
                                    }
                                }

                                // Update pattern color if sex layer is active
                                if (typeof updatePatternColor === 'function') {
                                    updatePatternColor(l, originalStyle.color);
                                }

                                // Clear religion colors reference
                                delete l._religionColors;
                            }
                        });
                    };

                    // Restore both plan layers
                    restorePlots(plotsLayer);
                    restorePlots(map2Layer);
                }

                // Event handlers for layer toggle
                ethnicReligiousLayer.on('add', function() {
                    applyReligionColoring();
                    if (typeof updateLegend === 'function') updateLegend();
                });

                ethnicReligiousLayer.on('remove', function() {
                    restoreOriginalColors();
                    if (typeof updateLegend === 'function') updateLegend();
                });

                // Event handlers for plan layers to reapply highlight effects
                historicalMapGroup.on('add', function() {
                    if (map.hasLayer(ethnicReligiousLayer)) {
                        applyReligionColoring();
                    }
                    if (map.hasLayer(highlightSexLayer)) {
                        applySexPatterns();
                    }
                    if (map.hasLayer(highlightSignificanceLayer)) {
                        applySignificanceMarkers();
                    }
                });

                historicalMapGroup.on('remove', function() {
                    if (map.hasLayer(highlightSexLayer)) {
                        removeSexPatternsFromLayer(plotsLayer);
                    }
                    if (map.hasLayer(highlightSignificanceLayer)) {
                        applySignificanceMarkers();
                    }
                });

                map2Group.on('add', function() {
                    if (map.hasLayer(ethnicReligiousLayer)) {
                        applyReligionColoring();
                    }
                    if (map.hasLayer(highlightSexLayer)) {
                        applySexPatterns();
                    }
                    if (map.hasLayer(highlightSignificanceLayer)) {
                        applySignificanceMarkers();
                    }
                });

                map2Group.on('remove', function() {
                    if (map.hasLayer(highlightSexLayer)) {
                        removeSexPatternsFromLayer(map2Layer);
                    }
                    if (map.hasLayer(highlightSignificanceLayer)) {
                        applySignificanceMarkers();
                    }
                });

                // ========================================
                // SEX HIGHLIGHTING LAYER
                // ========================================

                const highlightSexLayer = L.layerGroup();

                // ========================================
                // PATTERN CONFIGURATION
                // ========================================

                const MALE_PATTERN_CONFIG = {
                    width: 4,
                    height: 4,
                    rotation: 45,
                    lineStrokeWidth: 1,
                    opacity: 0.8
                };

                const FEMALE_PATTERN_CONFIG = {
                    width: 4,
                    height: 4,
                    dotRadius: 1,
                    opacity: 0.8
                };

                /**
                 * Generate CSS for male pattern (for legend)
                 */
                function getMalePatternCSS(color, bgColor = 'white') {
                    const cfg = MALE_PATTERN_CONFIG;
                    const rgb = hexToRgb(color);
                    const gapSize = cfg.width - cfg.lineStrokeWidth;
                    return `repeating-linear-gradient(135deg, transparent, transparent ${gapSize}px, rgba(${rgb}, ${cfg.opacity}) ${gapSize}px, rgba(${rgb}, ${cfg.opacity}) ${cfg.width}px), ${bgColor}`;
                }

                /**
                 * Generate CSS for female pattern (for legend)
                 */
                function getFemalePatternCSS(color, bgColor = 'white') {
                    const cfg = FEMALE_PATTERN_CONFIG;
                    const center = cfg.width / 2;
                    const rgb = hexToRgb(color);
                    return `radial-gradient(circle at ${center}px ${center}px, rgba(${rgb}, ${cfg.opacity}) ${cfg.dotRadius}px, transparent ${cfg.dotRadius}px), ${bgColor}`;
                }

                /**
                 * Convert hex color to RGB values
                 */
                function hexToRgb(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '51, 51, 51';
                }

                // Get SVG container for patterns
                let svgDefs = null;

                /**
                 * Initialize SVG patterns
                 */
                function initializeSVGPatterns() {
                    // Get the SVG element from Leaflet map
                    const svgElement = document.querySelector('.leaflet-overlay-pane svg');
                    if (!svgElement) return;

                    // Create or get <defs> element
                    svgDefs = svgElement.querySelector('defs');
                    if (!svgDefs) {
                        svgDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                        svgElement.insertBefore(svgDefs, svgElement.firstChild);
                    }
                }

                /**
                 * Create a stripe pattern for male with specific color
                 * Returns pattern ID
                 */
                createMalePattern = function(color) {
                    if (!svgDefs) initializeSVGPatterns();
                    if (!svgDefs) return null;

                    const cfg = MALE_PATTERN_CONFIG;

                    // Create unique ID based on color
                    const patternId = 'stripe-' + color.replace('#', '');

                    // Check if pattern already exists
                    if (document.getElementById(patternId)) {
                        return patternId;
                    }

                    // Create pattern element
                    const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                    pattern.setAttribute('id', patternId);
                    pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                    pattern.setAttribute('width', cfg.width.toString());
                    pattern.setAttribute('height', cfg.height.toString());
                    pattern.setAttribute('patternTransform', `rotate(${cfg.rotation})`);

                    // Create line for stripe
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', '0');
                    line.setAttribute('y1', '0');
                    line.setAttribute('x2', '0');
                    line.setAttribute('y2', cfg.height.toString());
                    line.setAttribute('stroke', color);
                    line.setAttribute('stroke-width', cfg.lineStrokeWidth.toString());
                    line.setAttribute('opacity', cfg.opacity.toString());

                    pattern.appendChild(line);
                    svgDefs.appendChild(pattern);

                    return patternId;
                }

                /**
                 * Create a dot pattern for female with specific color
                 * Returns pattern ID
                 */
                createFemalePattern = function(color) {
                    if (!svgDefs) initializeSVGPatterns();
                    if (!svgDefs) return null;

                    const cfg = FEMALE_PATTERN_CONFIG;

                    // Create unique ID based on color
                    const patternId = 'dots-' + color.replace('#', '');

                    // Check if pattern already exists
                    if (document.getElementById(patternId)) {
                        return patternId;
                    }

                    // Create pattern element
                    const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
                    pattern.setAttribute('id', patternId);
                    pattern.setAttribute('patternUnits', 'userSpaceOnUse');
                    pattern.setAttribute('width', cfg.width.toString());
                    pattern.setAttribute('height', cfg.height.toString());

                    // Create circle for dot
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    const center = cfg.width / 2;
                    circle.setAttribute('cx', center.toString());
                    circle.setAttribute('cy', center.toString());
                    circle.setAttribute('r', cfg.dotRadius.toString());
                    circle.setAttribute('fill', color);
                    circle.setAttribute('opacity', cfg.opacity.toString());

                    pattern.appendChild(circle);
                    svgDefs.appendChild(pattern);

                    return patternId;
                }

                /**
                 * Apply sex-based patterns to plot layers
                 */
                function applySexPatterns() {
                    // Initialize SVG patterns if not done yet
                    initializeSVGPatterns();

                    const applyToLayer = (layer) => {
                        if (!layer) return;

                        layer.eachLayer((l) => {
                            if (l.feature && l.feature.properties && l._path) {
                                const sex = l.feature.properties.Sex;
                                const borderColor = l.options.color || '#333';

                                // Skip if pattern already applied
                                if (l._sexPattern) {
                                    return;
                                }

                                if (sex === 'Male' || sex === 'Female') {
                                    // Create pattern
                                    const patternId = sex === 'Male'
                                        ? createMalePattern(borderColor)
                                        : createFemalePattern(borderColor);

                                    if (patternId) {
                                        // Clone the path element to create overlay with pattern
                                        const patternPath = l._path.cloneNode(true);
                                        patternPath.setAttribute('fill', `url(#${patternId})`);
                                        patternPath.setAttribute('stroke', 'none');
                                        patternPath.setAttribute('class', 'sex-pattern-overlay');

                                        // Make sure clicks pass through to original path
                                        patternPath.style.pointerEvents = 'none';

                                        // Insert pattern path after original path
                                        l._path.parentNode.insertBefore(patternPath, l._path.nextSibling);

                                        // Save references
                                        l._sexPattern = sex === 'Male' ? 'male' : 'female';
                                        l._patternId = patternId;
                                        l._patternPath = patternPath;

                                        // Create MutationObserver to sync pattern path with original path
                                        const observer = new MutationObserver((mutations) => {
                                            mutations.forEach((mutation) => {
                                                if (mutation.type === 'attributes' && mutation.attributeName === 'd') {
                                                    const newD = l._path.getAttribute('d');
                                                    if (newD && l._patternPath) {
                                                        l._patternPath.setAttribute('d', newD);
                                                    }
                                                }
                                            });
                                        });

                                        // Observe changes to the 'd' attribute of the original path
                                        observer.observe(l._path, {
                                            attributes: true,
                                            attributeFilter: ['d']
                                        });

                                        // Save observer reference for cleanup
                                        l._pathObserver = observer;
                                    }
                                }
                            }
                        });
                    };

                    // Apply patterns only to visible plan layers
                    if (map.hasLayer(historicalMapGroup)) {
                        applyToLayer(plotsLayer);
                    }
                    if (map.hasLayer(map2Group)) {
                        applyToLayer(map2Layer);
                    }
                }

                /**
                 * Remove sex-based patterns from a specific layer
                 */
                function removeSexPatternsFromLayer(layer) {
                    if (!layer) return;

                    layer.eachLayer((l) => {
                        // Disconnect MutationObserver
                        if (l._pathObserver) {
                            l._pathObserver.disconnect();
                            delete l._pathObserver;
                        }

                        // Remove the cloned pattern path overlay
                        if (l._patternPath && l._patternPath.parentNode) {
                            l._patternPath.remove();
                        }

                        // Ensure original path doesn't have pattern fill
                        if (l._path) {
                            const currentFill = l._path.getAttribute('fill');
                            if (currentFill && currentFill.includes('url(#')) {
                                l._path.removeAttribute('fill');
                            }
                        }

                        // Restore original fill color if ethnic layer is active
                        if (l.feature && l.setStyle) {
                            if (map.hasLayer(ethnicReligiousLayer) && l._religionColors) {
                                // Keep religion colors if ethnic layer is active
                                l.setStyle({
                                    fillColor: l._religionColors.plot
                                });
                            } else {
                                // Restore original colors
                                const originalStyle = getFeatureStyle(l.feature);
                                l.setStyle({
                                    fillColor: originalStyle.fillColor
                                });
                            }
                        }

                        // Clean up references
                        delete l._sexPattern;
                        delete l._patternId;
                        delete l._patternPath;
                    });
                }

                /**
                 * Remove sex-based patterns from all plot layers
                 */
                function removeSexPatterns() {
                    removeSexPatternsFromLayer(plotsLayer);
                    removeSexPatternsFromLayer(map2Layer);

                    // Also remove any orphaned pattern overlays by class
                    const orphanedPatterns = document.querySelectorAll('.sex-pattern-overlay');
                    orphanedPatterns.forEach(pattern => pattern.remove());
                }

                // Event handlers for sex layer toggle
                highlightSexLayer.on('add', function() {
                    applySexPatterns();
                    if (typeof updateLegend === 'function') updateLegend();
                });

                highlightSexLayer.on('remove', function() {
                    removeSexPatterns();
                    if (typeof updateLegend === 'function') updateLegend();
                });

                // ========================================
                // PLOT SIGNIFICANCE LAYER
                // ========================================

                const highlightSignificanceLayer = L.layerGroup();
                const significanceMarkersGroup = L.layerGroup();

                function createSignificanceMarker(latlng, type, highZoom) {
                    let svgHtml, iconSize, iconAnchor;

                    if (type === 'Religious') {
                        svgHtml = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14">' +
                                  '<polygon points="7,1 13,13 1,13" fill="white" stroke="#333" stroke-width="1.5" stroke-linejoin="round"/>' +
                                  '</svg>';
                        iconSize = [14, 14];
                        iconAnchor = highZoom ? [-7, 7] : [7, 7];
                    } else if (type === 'Economic') {
                        svgHtml = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12">' +
                                  '<rect x="1" y="1" width="10" height="10" fill="white" stroke="#333" stroke-width="1.5"/>' +
                                  '</svg>';
                        iconSize = [12, 12];
                        iconAnchor = highZoom ? [-7, 6] : [6, 6];
                    } else {
                        return null;
                    }

                    return L.marker(latlng, {
                        icon: L.divIcon({
                            className: 'significance-marker',
                            html: svgHtml,
                            iconSize: iconSize,
                            iconAnchor: iconAnchor
                        }),
                        interactive: false,
                        zIndexOffset: 100
                    });
                }

                let significanceHighZoom = null;

                function setFieldLabelOffset(polygonLayer, offsetRight) {
                    const marker = polygonLayer._fieldNumberMarker;
                    if (!marker) return;
                    const zoom = map.getZoom();
                    const className = zoom >= minZoomForLabels ? 'field-label' : 'field-label field-label-hidden';

                    if (offsetRight) {
                        if (!polygonLayer._origLabelHtml) {
                            polygonLayer._origLabelHtml = marker.options.icon.options.html;
                        }
                        marker.setIcon(L.divIcon({
                            className: className,
                            html: '<span style="display:block;text-align:right;width:22px;line-height:inherit;">'
                                  + polygonLayer._origLabelHtml + '</span>',
                            iconSize: [22, 20],
                            iconAnchor: [22, 10]
                        }));
                    } else {
                        marker.setIcon(L.divIcon({
                            className: className,
                            html: polygonLayer._origLabelHtml || marker.options.icon.options.html,
                            iconSize: [30, 20],
                            iconAnchor: [15, 10]
                        }));
                    }
                }

                function applySignificanceMarkers() {
                    significanceMarkersGroup.clearLayers();
                    const isHighZoom = map.getZoom() >= minZoomForLabels;
                    significanceHighZoom = isHighZoom;

                    const processLayer = (layer) => {
                        if (!layer) return;
                        layer.eachLayer((l) => {
                            if (!l.feature || !l.feature.properties) return;
                            const significance = l.feature.properties['Plot significance'];
                            if (!significance) return;
                            const center = l.getBounds().getCenter();
                            const marker = createSignificanceMarker(center, significance, isHighZoom);
                            if (marker) significanceMarkersGroup.addLayer(marker);
                            setFieldLabelOffset(l, isHighZoom);
                        });
                    };

                    if (map.hasLayer(historicalMapGroup)) processLayer(plotsLayer);
                    if (map.hasLayer(map2Group)) processLayer(map2Layer);

                    significanceMarkersGroup.addTo(map);
                }

                function removeSignificanceMarkers() {
                    significanceMarkersGroup.clearLayers();
                    if (map.hasLayer(significanceMarkersGroup)) {
                        map.removeLayer(significanceMarkersGroup);
                    }
                    // Restore field number labels to centered alignment
                    const restoreLayer = (layer) => {
                        if (!layer) return;
                        layer.eachLayer((l) => {
                            if (!l.feature || !l.feature.properties) return;
                            if (!l.feature.properties['Plot significance']) return;
                            setFieldLabelOffset(l, false);
                        });
                    };
                    if (map.hasLayer(historicalMapGroup)) restoreLayer(plotsLayer);
                    if (map.hasLayer(map2Group)) restoreLayer(map2Layer);
                    significanceHighZoom = null;
                }

                highlightSignificanceLayer.on('add', function() {
                    applySignificanceMarkers();
                    if (typeof updateLegend === 'function') updateLegend();
                });

                highlightSignificanceLayer.on('remove', function() {
                    removeSignificanceMarkers();
                    if (typeof updateLegend === 'function') updateLegend();
                });

                // Overlay maps for layer control
                const overlayMaps = {
                    "OpenStreetMap": osmLayer,
                    "Restoration plan 1888": historicalMapGroup,
                    "Restoration plan 1891": map2Group,
                    "Highlight ethnic and religious affiliation": ethnicReligiousLayer,
                    "Highlight sex": highlightSexLayer,
                    "Plot significance": highlightSignificanceLayer
                };

                // ========================================
                // MAP LEGEND
                // ========================================

                let legendDiv = null;
                let legendContentDiv = null;

                const legend = L.control({position: 'bottomleft'});

                legend.onAdd = function(map) {
                    legendDiv = L.DomUtil.create('div', 'legend');

                    // Toggle button
                    const toggleBtn = L.DomUtil.create('div', 'legend-toggle-btn', legendDiv);
                    toggleBtn.innerHTML = '<span>Legend</span><span class="legend-arrow">▼</span>';

                    // Content wrapper
                    legendContentDiv = L.DomUtil.create('div', 'legend-content', legendDiv);

                    // Update legend content
                    updateLegend();

                    // Toggle functionality
                    toggleBtn.addEventListener('click', () => {
                        legendContentDiv.classList.toggle('collapsed');
                        toggleBtn.classList.toggle('collapsed');
                    });

                    // Prevent map interaction
                    L.DomEvent.disableClickPropagation(toggleBtn);
                    L.DomEvent.disableScrollPropagation(legendDiv);

                    return legendDiv;
                };

                // Function to update legend based on active layers
                function updateLegend() {
                    if (!legendContentDiv) return;

                    const isReligiousLayerActive = map.hasLayer(ethnicReligiousLayer);
                    const isSexLayerActive = map.hasLayer(highlightSexLayer);
                    const isSignificanceLayerActive = map.hasLayer(highlightSignificanceLayer);

                    let legendHTML = '';

                    if (isReligiousLayerActive) {
                        // Show religion-based land plots
                        legendHTML += `
                            <div class="legend-item">
                                <span class="legend-color" style="background:#7b3294; border-color:#ffffff;"></span>
                                Jews land plots
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background:#a6d96a; border-color:#333;"></span>
                                Christians land plots
                            </div>
                        `;
                    } else {
                        // Show default land plots
                        legendHTML += `
                            <div class="legend-item">
                                <span class="legend-color" style="background:#78c679; border-color:#555;"></span>
                                Land plots
                            </div>
                        `;
                    }

                    // Always show plot subdivisions and buildings
                    legendHTML += `
                        <div class="legend-item">
                            <span class="legend-color" style="background:#c2e699; border-color:#78c679;"></span>
                            Plot subdivisions
                        </div>
                        <div class="legend-item">
                            <span class="legend-color" style="background:#ffffcc; border-color:#e6e6b3;"></span>
                            Buildings
                        </div>
                    `;

                    if (isSexLayerActive) {
                        const patternColor = '#333';
                        const malePatternCSS = getMalePatternCSS(patternColor);
                        const femalePatternCSS = getFemalePatternCSS(patternColor);

                        legendHTML += `
                            <div class="legend-item">
                                <span class="legend-color" style="background: ${malePatternCSS}; border-color:#333;"></span>
                                Male land plots
                            </div>
                            <div class="legend-item">
                                <span class="legend-color" style="background: ${femalePatternCSS}; background-size: ${FEMALE_PATTERN_CONFIG.width}px ${FEMALE_PATTERN_CONFIG.height}px; border-color:#333;"></span>
                                Female land plots
                            </div>
                        `;
                    }

                    if (isSignificanceLayerActive) {
                        legendHTML += `
                            <div class="legend-item">
                                <svg style="display:inline-block;vertical-align:middle;margin-right:5px;" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14">
                                    <polygon points="7,1 13,13 1,13" fill="white" stroke="#333" stroke-width="1.5" stroke-linejoin="round"/>
                                </svg>Religious significance
                            </div>
                            <div class="legend-item">
                                <svg style="display:inline-block;vertical-align:middle;margin-right:5px;" xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12">
                                    <rect x="1" y="1" width="10" height="10" fill="white" stroke="#333" stroke-width="1.5"/>
                                </svg>Economic significance
                            </div>
                        `;
                    }

                    legendContentDiv.innerHTML = `<div class="legend-content-inner">${legendHTML}</div>`;
                }

                legend.addTo(map);

                // ========================================
                // COLLAPSIBLE CONTROL PANEL
                // ========================================

                // Define map centers and zoom levels
                const map1Center = [54.154454, 27.243569]; // Map 1 center
                const map2Center = [54.160500, 27.235000]; // Map 2 center
                const navigationZoom = 17;

                // Store references to highlight layer controls
                let highlightEthnicLabel = null;
                let highlightSexLabel = null;
                let highlightSignificanceLabel = null;

                // Create collapsible control panel with all sections
                const ControlPanel = L.Control.extend({
                    options: {
                        position: 'topright'
                    },

                    onAdd: function(leafletMap) {
                        const container = L.DomUtil.create('div', 'leaflet-control-panel');

                        // Toggle button
                        const toggleBtn = L.DomUtil.create('div', 'panel-toggle-btn', container);
                        toggleBtn.innerHTML = '<span>Controls</span><span class="panel-arrow">▼</span>';

                        // Content wrapper
                        const content = L.DomUtil.create('div', 'panel-content', container);

                        // Section 1: Layer Control
                        const layerSection = this._createLayerSection(leafletMap, overlayMaps);
                        content.appendChild(layerSection);

                        // Section 2: Quick View
                        const navSection = this._createNavigationSection(leafletMap);
                        content.appendChild(navSection);

                        // Section 3: Download GeoJSON
                        const downloadSection = this._createDownloadSection();
                        content.appendChild(downloadSection);

                        // Toggle functionality
                        toggleBtn.addEventListener('click', () => {
                            content.classList.toggle('collapsed');
                            toggleBtn.classList.toggle('collapsed');
                        });

                        // Prevent map interaction for the entire control panel
                        L.DomEvent.disableClickPropagation(container);
                        L.DomEvent.disableScrollPropagation(container);
                        L.DomEvent.on(container, 'mousedown dblclick', function(e) {
                            L.DomEvent.stopPropagation(e);
                        });

                        return container;
                    },

                    _createLayerSection: function(leafletMap, layers) {
                        const section = L.DomUtil.create('div', 'panel-section');
                        const title = L.DomUtil.create('div', 'panel-section-title', section);
                        title.textContent = 'Layers';

                        Object.keys(layers).forEach(name => {
                            const label = L.DomUtil.create('label', 'layer-checkbox-label', section);

                            const checkbox = L.DomUtil.create('input', '', label);
                            checkbox.type = 'checkbox';
                            checkbox.checked = leafletMap.hasLayer(layers[name]);

                            const span = L.DomUtil.create('span', '', label);
                            span.textContent = name;

                            checkbox.addEventListener('change', () => {
                                if (checkbox.checked) {
                                    leafletMap.addLayer(layers[name]);
                                } else {
                                    leafletMap.removeLayer(layers[name]);
                                }
                            });

                            // Store references to highlight layer controls
                            if (name === "Highlight ethnic and religious affiliation") {
                                highlightEthnicLabel = label;
                            } else if (name === "Highlight sex") {
                                highlightSexLabel = label;
                            } else if (name === "Plot significance") {
                                highlightSignificanceLabel = label;
                            }
                        });

                        return section;
                    },

                    _createNavigationSection: function(leafletMap) {
                        const section = L.DomUtil.create('div', 'panel-section');
                        const title = L.DomUtil.create('div', 'panel-section-title', section);
                        title.textContent = 'Quick View';

                        const buttonsDiv = L.DomUtil.create('div', 'map-navigation-buttons', section);
                        buttonsDiv.innerHTML = `
                            <button class="map-nav-btn" data-view="map1">Plan 1888</button>
                            <button class="map-nav-btn" data-view="map2">Plan 1891</button>
                            <button class="map-nav-btn" data-view="initial">Initial view</button>
                        `;

                        return section;
                    },

                    _createDownloadSection: function() {
                        const section = L.DomUtil.create('div', 'panel-section download-section');

                        // Create clickable title with arrow
                        const titleWrapper = L.DomUtil.create('div', 'download-title-wrapper', section);
                        titleWrapper.innerHTML = '<span>Download GeoJSON</span><span class="download-title-arrow collapsed">▼</span>';

                        // Create three simple buttons (collapsed by default)
                        const buttonsContainer = L.DomUtil.create('div', 'download-buttons-container collapsed', section);

                        const btn1888 = L.DomUtil.create('button', 'download-plan-btn', buttonsContainer);
                        btn1888.innerHTML = '<span>Plan 1888</span><span class="download-plan-info">(4 files)</span>';
                        btn1888.setAttribute('data-plan', '1888');

                        const btn1891 = L.DomUtil.create('button', 'download-plan-btn', buttonsContainer);
                        btn1891.innerHTML = '<span>Plan 1891</span><span class="download-plan-info">(2 files)</span>';
                        btn1891.setAttribute('data-plan', '1891');

                        const btnAll = L.DomUtil.create('button', 'download-plan-btn download-all-btn', buttonsContainer);
                        btnAll.innerHTML = '<span>All Layers</span><span class="download-plan-info">(6 files)</span>';
                        btnAll.setAttribute('data-plan', 'all');

                        // Download function for plans
                        const downloadPlanZip = async (plan) => {
                            try {
                                if (typeof JSZip === 'undefined') {
                                    alert('JSZip library not loaded. Please refresh the page.');
                                    return;
                                }

                                const zip = new JSZip();
                                let files = [];
                                let zipName = '';

                                if (plan === '1888') {
                                    files = [
                                        'plan_1888_plots.geojson',
                                        'plan_1888_plot_subdivisions.geojson',
                                        'plan_1888_buildings.geojson',
                                        'plan_1888_labels.geojson'
                                    ];
                                    zipName = 'radashkovichy_plan_1888';
                                } else if (plan === '1891') {
                                    files = [
                                        'plan_1891_plots.geojson',
                                        'plan_1891_labels.geojson'
                                    ];
                                    zipName = 'radashkovichy_plan_1891';
                                } else if (plan === 'all') {
                                    files = [
                                        'plan_1888_plots.geojson',
                                        'plan_1888_plot_subdivisions.geojson',
                                        'plan_1888_buildings.geojson',
                                        'plan_1888_labels.geojson',
                                        'plan_1891_plots.geojson',
                                        'plan_1891_labels.geojson'
                                    ];
                                    zipName = 'radashkovichy_all_layers';
                                }

                                const promises = files.map(async (file) => {
                                    const response = await fetch(`data/${file}`);
                                    const content = await response.text();
                                    zip.file(file, content);
                                });

                                await Promise.all(promises);

                                const blob = await zip.generateAsync({ type: 'blob' });
                                const date = new Date().toISOString().split('T')[0];
                                const link = document.createElement('a');
                                link.href = URL.createObjectURL(blob);
                                link.download = `${zipName}_${date}.zip`;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                URL.revokeObjectURL(link.href);
                            } catch (error) {
                                alert('Error creating ZIP file. Please try again.');
                            }
                        };

                        // Add click handlers to buttons
                        [btn1888, btn1891, btnAll].forEach(btn => {
                            btn.addEventListener('click', () => {
                                const plan = btn.getAttribute('data-plan');
                                downloadPlanZip(plan);
                            });
                        });

                        // Toggle buttons visibility
                        titleWrapper.addEventListener('click', () => {
                            buttonsContainer.classList.toggle('collapsed');
                            titleWrapper.querySelector('.download-title-arrow').classList.toggle('collapsed');
                        });

                        return section;
                    }
                });

                const controlPanel = new ControlPanel();
                controlPanel.addTo(map);

                // Function to update availability of highlight layer controls
                function updateHighlightLayersVisibility() {
                    const hasMap1 = map.hasLayer(historicalMapGroup);
                    const hasMap2 = map.hasLayer(map2Group);
                    const hasAnyPlan = hasMap1 || hasMap2;

                    // Disable/enable checkboxes instead of hiding them
                    if (highlightEthnicLabel) {
                        const checkbox = highlightEthnicLabel.querySelector('input[type="checkbox"]');
                        if (checkbox) {
                            checkbox.disabled = !hasAnyPlan;
                            // Uncheck when disabled
                            if (!hasAnyPlan) {
                                checkbox.checked = false;
                            }
                        }
                        highlightEthnicLabel.style.opacity = hasAnyPlan ? '1' : '0.4';
                        highlightEthnicLabel.style.pointerEvents = hasAnyPlan ? '' : 'none';
                    }
                    if (highlightSexLabel) {
                        const checkbox = highlightSexLabel.querySelector('input[type="checkbox"]');
                        if (checkbox) {
                            checkbox.disabled = !hasAnyPlan;
                            // Uncheck when disabled
                            if (!hasAnyPlan) {
                                checkbox.checked = false;
                            }
                        }
                        highlightSexLabel.style.opacity = hasAnyPlan ? '1' : '0.4';
                        highlightSexLabel.style.pointerEvents = hasAnyPlan ? '' : 'none';
                    }
                    if (highlightSignificanceLabel) {
                        const checkbox = highlightSignificanceLabel.querySelector('input[type="checkbox"]');
                        if (checkbox) {
                            checkbox.disabled = !hasAnyPlan;
                            if (!hasAnyPlan) {
                                checkbox.checked = false;
                            }
                        }
                        highlightSignificanceLabel.style.opacity = hasAnyPlan ? '1' : '0.4';
                        highlightSignificanceLabel.style.pointerEvents = hasAnyPlan ? '' : 'none';
                    }

                    // If no plans are visible, remove highlight layers
                    if (!hasAnyPlan) {
                        if (map.hasLayer(ethnicReligiousLayer)) {
                            map.removeLayer(ethnicReligiousLayer);
                        }
                        if (map.hasLayer(highlightSexLayer)) {
                            map.removeLayer(highlightSexLayer);
                        }
                        if (map.hasLayer(highlightSignificanceLayer)) {
                            map.removeLayer(highlightSignificanceLayer);
                        }
                    }
                }

                // Add event listeners to plan layers
                historicalMapGroup.on('add', updateHighlightLayersVisibility);
                historicalMapGroup.on('remove', updateHighlightLayersVisibility);
                map2Group.on('add', updateHighlightLayersVisibility);
                map2Group.on('remove', updateHighlightLayersVisibility);

                // Initial visibility update
                updateHighlightLayersVisibility();

                // Add click handlers for navigation buttons
                document.querySelectorAll('.map-nav-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const view = this.getAttribute('data-view');

                        // Handle view switching
                        if (view === 'map1') {
                            // Ensure Map 1 layer is visible
                            if (!map.hasLayer(historicalMapGroup)) {
                                map.addLayer(historicalMapGroup);
                            }
                            // Fly to Map 1 center
                            map.flyTo(map1Center, navigationZoom, {
                                duration: 1.5,
                                easeLinearity: 0.5
                            });
                        } else if (view === 'map2') {
                            // Ensure Map 2 layer is visible
                            if (!map.hasLayer(map2Group)) {
                                map.addLayer(map2Group);
                            }
                            // Fly to Map 2 center
                            map.flyTo(map2Center, navigationZoom, {
                                duration: 1.5,
                                easeLinearity: 0.5
                            });
                        } else if (view === 'initial') {
                            map.flyTo(mapCenter, initialZoom, {
                                duration: 1.5,
                                easeLinearity: 0.5
                            });
                        }
                    });
                });

                // ========================================
                // LABEL VISIBILITY MANAGEMENT
                // ========================================

                // Update visibility of plot numbers and street labels based on zoom level
                function updateLabelsVisibility() {
                    const zoom = map.getZoom();

                    // Toggle plot number visibility for map1
                    fieldLabelsGroup.eachLayer(marker => {
                        const element = marker.getElement();
                        if (element) {
                            if (zoom >= minZoomForLabels) {
                                element.classList.remove('field-label-hidden');
                            } else {
                                element.classList.add('field-label-hidden');
                            }
                        }
                    });

                    // Toggle plot number visibility for map2
                    map2LabelsGroup.eachLayer(marker => {
                        const element = marker.getElement();
                        if (element) {
                            if (zoom >= minZoomForLabels) {
                                element.classList.remove('field-label-hidden');
                            } else {
                                element.classList.add('field-label-hidden');
                            }
                        }
                    });

                    // Toggle street label visibility for map1
                    streetLabelsGroup.eachLayer(marker => {
                        const element = marker.getElement();
                        if (element) {
                            if (zoom >= minZoomForLabels) {
                                element.classList.remove('leaflet-text-path-hidden');
                            } else {
                                element.classList.add('leaflet-text-path-hidden');
                            }
                        }
                    });

                    // Toggle street label visibility for map2
                    map2StreetLabelsGroup.eachLayer(marker => {
                        const element = marker.getElement();
                        if (element) {
                            if (zoom >= minZoomForLabels) {
                                element.classList.remove('leaflet-text-path-hidden');
                            } else {
                                element.classList.add('leaflet-text-path-hidden');
                            }
                        }
                    });

                    // Reposition significance markers when crossing the zoom threshold
                    if (map.hasLayer(highlightSignificanceLayer)) {
                        const isHighZoom = zoom >= minZoomForLabels;
                        if (significanceHighZoom !== isHighZoom) {
                            applySignificanceMarkers();
                        }
                    }
                }

                // Initialize label visibility
                updateLabelsVisibility();

                // Update on zoom and move events
                map.on('zoomend moveend', updateLabelsVisibility);

                // Update label visibility when layers are added/removed via layer control
                map.on('overlayadd', function(e) {
                    // Check if the added layer contains our label groups
                    const zoom = map.getZoom();
                    const shouldHideLabels = zoom < minZoomForLabels;

                    // Use requestAnimationFrame for faster, smoother update
                    requestAnimationFrame(() => {
                        // Apply visibility based on current zoom immediately
                        fieldLabelsGroup.eachLayer(marker => {
                            const element = marker.getElement();
                            if (element) {
                                if (shouldHideLabels) {
                                    element.classList.add('field-label-hidden');
                                } else {
                                    element.classList.remove('field-label-hidden');
                                }
                            }
                        });

                        map2LabelsGroup.eachLayer(marker => {
                            const element = marker.getElement();
                            if (element) {
                                if (shouldHideLabels) {
                                    element.classList.add('field-label-hidden');
                                } else {
                                    element.classList.remove('field-label-hidden');
                                }
                            }
                        });

                        streetLabelsGroup.eachLayer(marker => {
                            const element = marker.getElement();
                            if (element) {
                                if (shouldHideLabels) {
                                    element.classList.add('leaflet-text-path-hidden');
                                } else {
                                    element.classList.remove('leaflet-text-path-hidden');
                                }
                            }
                        });

                        map2StreetLabelsGroup.eachLayer(marker => {
                            const element = marker.getElement();
                            if (element) {
                                if (shouldHideLabels) {
                                    element.classList.add('leaflet-text-path-hidden');
                                } else {
                                    element.classList.remove('leaflet-text-path-hidden');
                                }
                            }
                        });
                    });
                });

                // ========================================
                // POPULATE TABLE
                // ========================================

                saveTableData(allFeatures, plan1891PlotsData.features);
                populateTable(allTableData);
            })
            .catch(error => {
                console.error('Error loading map data:', error);
                alert('Failed to load map data. Please check that files exist in the data/ folder.\n\nError: ' + error.message);
            });

            // ========================================
            // TABLE POPULATION FUNCTIONS
            // ========================================

            // Populate table with feature data
            function populateTable(features) {
                const tableBody = document.getElementById('data-table-body');
                tableBody.innerHTML = '';

                let rowCount = 0;

                features.forEach((feature, index) => {
                    const props = feature.properties;
                    const isMap2 = props.source_layer === 'plan_1891_plots';

                    const row = document.createElement('tr');
                    row.dataset.featureIndex = index;
                    row.dataset.fid = props.fid; // Unique feature ID for lookup
                    row.dataset.sourceLayer = props.source_layer; // Store source layer for lookup

                    // Extract data based on source (store raw values, not '-')
                    const displayNumber = props['Field number'];
                    const firstNameTranslit = props['First name translit'];
                    const lastNameTranslit = props['Last name translit'];
                    const patronymicTranslit = props['Patronymic translit'];
                    const firstNameNative = props['First name native'];
                    const lastNameNative = props['Last name native'];
                    const patronymicNative = props['Patronymic native'];
                    const religion = props['Religion'];
                    const sex = props['Sex'];
                    const length = isMap2 ? props['Length of plot'] : props['Length of plots'];
                    const width = isMap2 ? props['Width of plot'] : props['Width of plots'];
                    const planPart = isMap2 ? props['Plan part'] : null;
                    const note = props['Note'];

                    row.innerHTML = `
                        <td>${displayNumber || '-'}</td>
                        <td>${firstNameTranslit || '-'}</td>
                        <td>${lastNameTranslit || '-'}</td>
                        <td>${patronymicTranslit || '-'}</td>
                        <td>${firstNameNative || '-'}</td>
                        <td>${lastNameNative || '-'}</td>
                        <td>${patronymicNative || '-'}</td>
                        <td>${religion || '-'}</td>
                        <td>${sex || '-'}</td>
                        <td>${length || '-'}</td>
                        <td>${width || '-'}</td>
                        <td>${planPart || '-'}</td>
                        <td>${note || '-'}</td>
                    `;

                    // Click row to open popup on map
                    row.addEventListener('click', function() {
                        openPopupForPlot(this.dataset.fid, this.dataset.sourceLayer);
                    });

                    tableBody.appendChild(row);
                    rowCount++;
                });

                // Update header with count
                const recordLabel = rowCount === 1 ? 'record' : 'records';
                document.getElementById('table-title').textContent =
                    `Land Plots (${rowCount} ${recordLabel})`;
            }

            // Flag to track if popup was opened from table row click
            let openedFromTableClick = false;

            // Scroll row to the top of table container (without scrolling the page)
            function scrollRowIntoView(row) {
                const tableContainer = document.getElementById('table-container');
                const tableHeader = document.querySelector('#data-table thead');
                const headerHeight = tableHeader ? tableHeader.offsetHeight : 0;

                // Calculate row position relative to table start
                const rowTop = row.offsetTop;

                // Scroll so the row appears right below the sticky header
                tableContainer.scrollTop = rowTop - headerHeight - 5; // 5px padding
            }

            // Open popup for plot when clicking table row (called from table row click)
            function openPopupForPlot(fid, sourceLayer) {
                // Set flag to prevent scrolling when popup opens
                openedFromTableClick = true;

                // Clear previous table selection
                document.querySelectorAll('#data-table tbody tr.selected').forEach(row => {
                    row.classList.remove('selected');
                });

                // Highlight selected row (but don't scroll yet)
                document.querySelectorAll('#data-table tbody tr').forEach(row => {
                    if (row.dataset.fid == fid && row.dataset.sourceLayer == sourceLayer) {
                        row.classList.add('selected');
                    }
                });

                // Determine which layer to search based on sourceLayer
                const targetLayer = sourceLayer === 'plan_1891_plots' ? map2Layer : combinedLayer;
                const targetSourceLayer = sourceLayer === 'plan_1891_plots' ? 'plan_1891_plots' : 'plan_1888_plots';

                if (!targetLayer) return;

                // Find layer by unique feature ID
                targetLayer.eachLayer(function(layer) {
                    if (layer.feature &&
                        layer.feature.properties.source_layer === targetSourceLayer &&
                        layer.feature.properties.fid == fid) {

                        const center = layer.getBounds().getCenter();

                        // Pan and zoom to plot (without animating to prevent page scroll)
                        map.setView(center, Math.max(map.getZoom(), 18), { animate: false });

                        // Open popup
                        if (layer.getPopup()) {
                            layer.openPopup();
                        }
                    }
                });

                // Reset flag after popup opens
                setTimeout(() => {
                    openedFromTableClick = false;
                }, 100);
            }

            // ========================================
            // SEARCH AND SORT IN TABLE
            // ========================================

            let allTableData = [];
            let currentSortColumn = null; // No column sorted by default (initial sort is by plan and owner)
            let currentSortDirection = 'asc'; // ascending

            // Save data for search and sort
            function saveTableData(features, plan1891Features) {
                // Filter plan 1888 features (only plots, not buildings/subdivisions)
                const plan1888Data = features.filter(feature => {
                    const sourceLayer = feature.properties.source_layer;
                    return sourceLayer === 'plan_1888_plots';
                });

                // Include all plan 1891 features
                const plan1891Data = plan1891Features;

                // Combine both datasets
                allTableData = [...plan1888Data, ...plan1891Data];

                // Populate filter options
                populatePlanPartFilter();
                populateReligionFilter();
                populateSexFilter();

                // Apply default sorting by plan and owner name
                initialSortTableData();
            }

            // Track selected values for multiselect filters
            let selectedPlanParts = new Set();
            let selectedReligions = new Set();
            let selectedSexes = new Set();

            // Populate Plan part multiselect with unique values
            function populatePlanPartFilter() {
                const uniquePlanParts = new Set();

                // Collect unique Plan part values from map2 data
                allTableData.forEach(feature => {
                    const props = feature.properties;
                    const isMap2 = props.source_layer === 'plan_1891_plots';

                    if (isMap2 && props['Plan part']) {
                        uniquePlanParts.add(props['Plan part']);
                    }
                });

                // Get the options container
                const optionsContainer = document.querySelector('#planpart-multiselect .multiselect-options');
                optionsContainer.innerHTML = '';

                // Add checkboxes for each unique plan part
                Array.from(uniquePlanParts).sort().forEach(planPart => {
                    const option = document.createElement('div');
                    option.className = 'multiselect-option';

                    const label = document.createElement('label');

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = planPart;

                    const text = document.createTextNode(planPart);

                    label.appendChild(checkbox);
                    label.appendChild(text);
                    option.appendChild(label);

                    // Handle checkbox change
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedPlanParts.add(this.value);
                        } else {
                            selectedPlanParts.delete(this.value);
                        }
                        updatePlanPartDisplay();
                        applyFilters();
                    });

                    optionsContainer.appendChild(option);
                });

                // Initialize display
                updatePlanPartDisplay();
            }

            // Update the multiselect display text
            function updatePlanPartDisplay() {
                const selectedDiv = document.querySelector('#planpart-multiselect .multiselect-selected');
                const clearButton = document.getElementById('clear-planpart');

                if (selectedPlanParts.size === 0) {
                    selectedDiv.innerHTML = '<span class="multiselect-placeholder">Select Plan Parts...</span>';
                    clearButton.style.display = 'none';
                } else {
                    selectedDiv.innerHTML = `<span class="multiselect-count">${selectedPlanParts.size} selected</span>`;
                    clearButton.style.display = 'block';
                }
            }

            // Toggle multiselect dropdown for all multiselect elements
            document.addEventListener('click', function(e) {
                // Handle all multiselect dropdowns
                document.querySelectorAll('.multiselect-dropdown').forEach(multiselect => {
                    const selected = multiselect.querySelector('.multiselect-selected');
                    const options = multiselect.querySelector('.multiselect-options');

                    if (selected.contains(e.target)) {
                        // Close all other dropdowns
                        document.querySelectorAll('.multiselect-dropdown .multiselect-options').forEach(opt => {
                            if (opt !== options) {
                                opt.classList.remove('show');
                            }
                        });
                        // Toggle current dropdown
                        options.classList.toggle('show');
                    } else if (!multiselect.contains(e.target)) {
                        options.classList.remove('show');
                    }
                });
            });

            // Populate Religion filter with unique values
            function populateReligionFilter() {
                const uniqueReligions = new Set();
                let hasEmpty = false;

                // Collect unique Religion values
                allTableData.forEach(feature => {
                    const props = feature.properties;
                    if (props['Religion']) {
                        uniqueReligions.add(props['Religion']);
                    } else {
                        hasEmpty = true;
                    }
                });

                // Get the options container
                const optionsContainer = document.querySelector('#religion-multiselect .multiselect-options');
                optionsContainer.innerHTML = '';

                // Add "No Data" option if there are empty values
                if (hasEmpty) {
                    const option = document.createElement('div');
                    option.className = 'multiselect-option';

                    const label = document.createElement('label');

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = '__NO_DATA__';

                    const text = document.createTextNode('No Data');

                    label.appendChild(checkbox);
                    label.appendChild(text);
                    option.appendChild(label);

                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedReligions.add(this.value);
                        } else {
                            selectedReligions.delete(this.value);
                        }
                        updateReligionDisplay();
                        applyFilters();
                    });

                    optionsContainer.appendChild(option);
                }

                // Add checkboxes for each unique religion
                Array.from(uniqueReligions).sort().forEach(religion => {
                    const option = document.createElement('div');
                    option.className = 'multiselect-option';

                    const label = document.createElement('label');

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = religion;

                    const text = document.createTextNode(religion);

                    label.appendChild(checkbox);
                    label.appendChild(text);
                    option.appendChild(label);

                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedReligions.add(this.value);
                        } else {
                            selectedReligions.delete(this.value);
                        }
                        updateReligionDisplay();
                        applyFilters();
                    });

                    optionsContainer.appendChild(option);
                });

                // Initialize display
                updateReligionDisplay();
            }

            // Update the religion multiselect display text
            function updateReligionDisplay() {
                const selectedDiv = document.querySelector('#religion-multiselect .multiselect-selected');
                const clearButton = document.getElementById('clear-religion');

                if (selectedReligions.size === 0) {
                    selectedDiv.innerHTML = '<span class="multiselect-placeholder">Select Religion...</span>';
                    clearButton.style.display = 'none';
                } else {
                    selectedDiv.innerHTML = `<span class="multiselect-count">${selectedReligions.size} selected</span>`;
                    clearButton.style.display = 'block';
                }
            }

            // Populate Sex filter with unique values
            function populateSexFilter() {
                const uniqueSexes = new Set();
                let hasEmpty = false;

                // Collect unique Sex values
                allTableData.forEach(feature => {
                    const props = feature.properties;
                    if (props['Sex']) {
                        uniqueSexes.add(props['Sex']);
                    } else {
                        hasEmpty = true;
                    }
                });

                // Get the options container
                const optionsContainer = document.querySelector('#sex-multiselect .multiselect-options');
                optionsContainer.innerHTML = '';

                // Add checkboxes for each unique sex
                Array.from(uniqueSexes).sort().forEach(sex => {
                    const option = document.createElement('div');
                    option.className = 'multiselect-option';

                    const label = document.createElement('label');

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = sex;

                    const text = document.createTextNode(sex);

                    label.appendChild(checkbox);
                    label.appendChild(text);
                    option.appendChild(label);

                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedSexes.add(this.value);
                        } else {
                            selectedSexes.delete(this.value);
                        }
                        updateSexDisplay();
                        applyFilters();
                    });

                    optionsContainer.appendChild(option);
                });

                // Add "Not Applicable" option at the end if there are empty values
                if (hasEmpty) {
                    const option = document.createElement('div');
                    option.className = 'multiselect-option';

                    const label = document.createElement('label');

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = '__NO_DATA__';

                    const text = document.createTextNode('Not Applicable');

                    label.appendChild(checkbox);
                    label.appendChild(text);
                    option.appendChild(label);

                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedSexes.add(this.value);
                        } else {
                            selectedSexes.delete(this.value);
                        }
                        updateSexDisplay();
                        applyFilters();
                    });

                    optionsContainer.appendChild(option);
                }

                // Initialize display
                updateSexDisplay();
            }

            // Update the sex multiselect display text
            function updateSexDisplay() {
                const selectedDiv = document.querySelector('#sex-multiselect .multiselect-selected');
                const clearButton = document.getElementById('clear-sex');

                if (selectedSexes.size === 0) {
                    selectedDiv.innerHTML = '<span class="multiselect-placeholder">Select Sex...</span>';
                    clearButton.style.display = 'none';
                } else {
                    selectedDiv.innerHTML = `<span class="multiselect-count">${selectedSexes.size} selected</span>`;
                    clearButton.style.display = 'block';
                }
            }

            // Sort table data
            function sortTableData(column, direction) {
                allTableData.sort((a, b) => {
                    let valueA, valueB;
                    const propsA = a.properties;
                    const propsB = b.properties;
                    const isMap2A = propsA.source_layer === 'plan_1891_plots';
                    const isMap2B = propsB.source_layer === 'plan_1891_plots';

                    switch(column) {
                        case 'number':
                            valueA = parseInt(propsA['Field number']) || 0;
                            valueB = parseInt(propsB['Field number']) || 0;
                            break;
                        case 'firstnametranslit':
                            valueA = (propsA['First name translit'] || '').toLowerCase();
                            valueB = (propsB['First name translit'] || '').toLowerCase();
                            break;
                        case 'lastnametranslit':
                            valueA = (propsA['Last name translit'] || '').toLowerCase();
                            valueB = (propsB['Last name translit'] || '').toLowerCase();
                            break;
                        case 'patronymictranslit':
                            valueA = (propsA['Patronymic translit'] || '').toLowerCase();
                            valueB = (propsB['Patronymic translit'] || '').toLowerCase();
                            break;
                        case 'firstnamenative':
                            valueA = (propsA['First name native'] || '').toLowerCase();
                            valueB = (propsB['First name native'] || '').toLowerCase();
                            break;
                        case 'lastnamenative':
                            valueA = (propsA['Last name native'] || '').toLowerCase();
                            valueB = (propsB['Last name native'] || '').toLowerCase();
                            break;
                        case 'patronymicnative':
                            valueA = (propsA['Patronymic native'] || '').toLowerCase();
                            valueB = (propsB['Patronymic native'] || '').toLowerCase();
                            break;
                        case 'length':
                            valueA = parseFloat(isMap2A ? propsA['Length of plot'] : propsA['Length of plots']) || 0;
                            valueB = parseFloat(isMap2B ? propsB['Length of plot'] : propsB['Length of plots']) || 0;
                            break;
                        case 'width':
                            valueA = parseFloat(isMap2A ? propsA['Width of plot'] : propsA['Width of plots']) || 0;
                            valueB = parseFloat(isMap2B ? propsB['Width of plot'] : propsB['Width of plots']) || 0;
                            break;
                        case 'planpart':
                            valueA = isMap2A ? (propsA['Plan part'] || '').toLowerCase() : '';
                            valueB = isMap2B ? (propsB['Plan part'] || '').toLowerCase() : '';
                            break;
                        case 'religion':
                            valueA = (propsA['Religion'] || '').toLowerCase();
                            valueB = (propsB['Religion'] || '').toLowerCase();
                            break;
                        case 'sex':
                            valueA = (propsA['Sex'] || '').toLowerCase();
                            valueB = (propsB['Sex'] || '').toLowerCase();
                            break;
                        case 'note':
                            valueA = (propsA['Note'] || '').toLowerCase();
                            valueB = (propsB['Note'] || '').toLowerCase();
                            break;
                        default:
                            return 0;
                    }

                    // Check if values are empty (null, undefined, empty string, or just '-')
                    const isEmptyA = !valueA || valueA === '' || valueA === '-' || (typeof valueA === 'number' && valueA === 0);
                    const isEmptyB = !valueB || valueB === '' || valueB === '-' || (typeof valueB === 'number' && valueB === 0);

                    // Empty values always go last
                    if (isEmptyA && !isEmptyB) return 1;
                    if (!isEmptyA && isEmptyB) return -1;
                    if (isEmptyA && isEmptyB) return 0;

                    if (valueA < valueB) return direction === 'asc' ? -1 : 1;
                    if (valueA > valueB) return direction === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Initial sort by plan and then by owner name
            function initialSortTableData() {
                allTableData.sort((a, b) => {
                    const propsA = a.properties;
                    const propsB = b.properties;
                    const isMap2A = propsA.source_layer === 'plan_1891_plots';
                    const isMap2B = propsB.source_layer === 'plan_1891_plots';

                    // First, sort by plan (1888 before 1891)
                    if (!isMap2A && isMap2B) return -1; // plan 1888 before plan 1891
                    if (isMap2A && !isMap2B) return 1;  // plan 1891 after plan 1888

                    // Within each plan, sort by last name
                    const lastNameA = (propsA['Last name translit'] || propsA['Last name native'] || '').toLowerCase();
                    const lastNameB = (propsB['Last name translit'] || propsB['Last name native'] || '').toLowerCase();

                    // Check if last names are empty
                    const isEmptyA = !lastNameA || lastNameA === '' || lastNameA === '-';
                    const isEmptyB = !lastNameB || lastNameB === '' || lastNameB === '-';

                    // Empty last names always go last within their plan
                    if (isEmptyA && !isEmptyB) return 1;
                    if (!isEmptyA && isEmptyB) return -1;
                    if (isEmptyA && isEmptyB) return 0;

                    if (lastNameA < lastNameB) return -1;
                    if (lastNameA > lastNameB) return 1;
                    return 0;
                });
            }

            // Handle column header click for sorting
            function handleSort(column) {
                // Toggle direction if clicking the same column
                if (currentSortColumn === column) {
                    currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSortColumn = column;
                    currentSortDirection = 'asc';
                }

                sortTableData(currentSortColumn, currentSortDirection);

                // Re-apply all filters after sorting
                applyFilters();

                // Update visual indicators
                updateSortIndicators();
            }

            // Update sort indicators in table headers
            function updateSortIndicators() {
                document.querySelectorAll('#data-table th').forEach(th => {
                    th.classList.remove('sort-asc', 'sort-desc');
                    const sortColumn = th.getAttribute('data-sort');
                    if (sortColumn === currentSortColumn) {
                        th.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                    }
                });
            }

            // Update active filters badge
            function updateActiveFiltersBadge() {
                let activeCount = 0;

                const searchTerm = document.getElementById('search-input').value.trim();
                const ownerFilter = document.getElementById('filter-owner').value.trim();
                const mapFilter = document.getElementById('filter-map').value;

                if (searchTerm !== '') activeCount++;
                if (ownerFilter !== '') activeCount++;
                if (mapFilter !== '') activeCount++;
                if (selectedPlanParts.size > 0) activeCount++;
                if (selectedReligions.size > 0) activeCount++;
                if (selectedSexes.size > 0) activeCount++;

                const badge = document.getElementById('filters-active-badge');
                if (activeCount > 0) {
                    badge.textContent = activeCount + ' active';
                    badge.classList.add('show');
                } else {
                    badge.classList.remove('show');
                }

                // Show/hide clear all filters button
                const clearAllBtn = document.getElementById('clear-all-filters-wrapper');
                if (activeCount > 0) {
                    clearAllBtn.classList.add('show');
                } else {
                    clearAllBtn.classList.remove('show');
                }
            }

            // Apply all filters (search + owner + plan part + map + religion + sex)
            function applyFilters() {
                // Get all filter values
                const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
                const ownerFilter = document.getElementById('filter-owner').value.toLowerCase().trim();
                const mapFilter = document.getElementById('filter-map').value;

                // Update clear button visibility
                updateClearButtonVisibility();

                // Update active filters badge
                updateActiveFiltersBadge();

                // Filter data
                const filtered = allTableData.filter(feature => {
                    const props = feature.properties;
                    const isMap2 = props.source_layer === 'plan_1891_plots';

                    // Filter by map number
                    if (mapFilter !== '') {
                        if (mapFilter === 'map1' && isMap2) return false;
                        if (mapFilter === 'map2' && !isMap2) return false;
                    }

                    // Filter by religion (multiselect)
                    if (selectedReligions.size > 0) {
                        const religion = props['Religion'] || '';
                        const isEmpty = !religion;

                        // Check if "No Data" is selected and record is empty
                        const matchesNoData = selectedReligions.has('__NO_DATA__') && isEmpty;
                        // Check if the value is in selected religions
                        const matchesValue = selectedReligions.has(religion);

                        if (!matchesNoData && !matchesValue) return false;
                    }

                    // Filter by sex (multiselect)
                    if (selectedSexes.size > 0) {
                        const sex = props['Sex'] || '';
                        const isEmpty = !sex;

                        // Check if "No Data" is selected and record is empty
                        const matchesNoData = selectedSexes.has('__NO_DATA__') && isEmpty;
                        // Check if the value is in selected sexes
                        const matchesValue = selectedSexes.has(sex);

                        if (!matchesNoData && !matchesValue) return false;
                    }

                    // Filter by search term (plot number or any name field)
                    if (searchTerm !== '') {
                        let matchesSearch = false;

                        // Check plot number
                        const fieldNumber = String(props['Field number'] || '').toLowerCase();
                        if (fieldNumber.includes(searchTerm)) matchesSearch = true;

                        // Check all name fields (translit)
                        const firstNameTranslit = String(props['First name translit'] || '').toLowerCase();
                        const lastNameTranslit = String(props['Last name translit'] || '').toLowerCase();
                        const patronymicTranslit = String(props['Patronymic translit'] || '').toLowerCase();
                        if (firstNameTranslit.includes(searchTerm) || lastNameTranslit.includes(searchTerm) || patronymicTranslit.includes(searchTerm)) {
                            matchesSearch = true;
                        }

                        // Check all name fields (native)
                        const firstNameNative = String(props['First name native'] || '').toLowerCase();
                        const lastNameNative = String(props['Last name native'] || '').toLowerCase();
                        const patronymicNative = String(props['Patronymic native'] || '').toLowerCase();
                        if (firstNameNative.includes(searchTerm) || lastNameNative.includes(searchTerm) || patronymicNative.includes(searchTerm)) {
                            matchesSearch = true;
                        }

                        // Check Length
                        const length = String(isMap2 ? (props['Length of plot'] || '') : (props['Length of plots'] || '')).toLowerCase();
                        if (length.includes(searchTerm)) matchesSearch = true;

                        // Check Width
                        const width = String(isMap2 ? (props['Width of plot'] || '') : (props['Width of plots'] || '')).toLowerCase();
                        if (width.includes(searchTerm)) matchesSearch = true;

                        // Check plan part
                        if (isMap2) {
                            const planPart = String(props['Plan part'] || '').toLowerCase();
                            if (planPart.includes(searchTerm)) matchesSearch = true;
                        }

                        // Check Religion
                        const religion = String(props['Religion'] || '').toLowerCase();
                        if (religion.includes(searchTerm)) matchesSearch = true;

                        // Check Sex
                        const sex = String(props['Sex'] || '').toLowerCase();
                        if (sex.includes(searchTerm)) matchesSearch = true;

                        // Check Note
                        const note = String(props['Note'] || '').toLowerCase();
                        if (note.includes(searchTerm)) matchesSearch = true;

                        // Check Note native
                        const noteNative = String(props['Note native'] || '').toLowerCase();
                        if (noteNative.includes(searchTerm)) matchesSearch = true;

                        if (!matchesSearch) return false;
                    }

                    // Filter by owner name
                    if (ownerFilter !== '') {
                        let matchesOwner = false;

                        // Check all name fields (translit)
                        const firstNameTranslit = String(props['First name translit'] || '').toLowerCase();
                        const lastNameTranslit = String(props['Last name translit'] || '').toLowerCase();
                        const patronymicTranslit = String(props['Patronymic translit'] || '').toLowerCase();
                        if (firstNameTranslit.includes(ownerFilter) || lastNameTranslit.includes(ownerFilter) || patronymicTranslit.includes(ownerFilter)) {
                            matchesOwner = true;
                        }

                        // Check all name fields (native)
                        const firstNameNative = String(props['First name native'] || '').toLowerCase();
                        const lastNameNative = String(props['Last name native'] || '').toLowerCase();
                        const patronymicNative = String(props['Patronymic native'] || '').toLowerCase();
                        if (firstNameNative.includes(ownerFilter) || lastNameNative.includes(ownerFilter) || patronymicNative.includes(ownerFilter)) {
                            matchesOwner = true;
                        }

                        if (!matchesOwner) return false;
                    }

                    // Filter by plan part (multiselect)
                    if (selectedPlanParts.size > 0) {
                        if (!isMap2) return false; // Plan part only exists in map2
                        const planPart = String(props['Plan part'] || '');
                        if (!selectedPlanParts.has(planPart)) return false;
                    }

                    return true;
                });

                populateTable(filtered);

                // Update CSV filtered option visibility
                updateCSVFilteredOption();
            }

            // Deprecated: kept for compatibility
            function searchTable(searchTerm) {
                applyFilters();
            }

            // Search handler (with delay for optimization)
            let searchTimeout;
            document.getElementById('search-input').addEventListener('input', function(e) {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyFilters();
                }, 300);
            });

            // Owner filter handler
            let ownerFilterTimeout;
            document.getElementById('filter-owner').addEventListener('input', function(e) {
                clearTimeout(ownerFilterTimeout);
                ownerFilterTimeout = setTimeout(() => {
                    applyFilters();
                }, 300);
            });

            // Map filter handler
            document.getElementById('filter-map').addEventListener('change', function(e) {
                applyFilters();
            });

            // Update clear button visibility based on filter values
            function updateClearButtonVisibility() {
                // Search input
                const searchInput = document.getElementById('search-input');
                const searchWrapper = document.getElementById('search-wrapper');
                if (searchInput.value.trim() !== '') {
                    searchWrapper.classList.add('has-value');
                } else {
                    searchWrapper.classList.remove('has-value');
                }

                // Owner filter input
                const ownerInput = document.getElementById('filter-owner');
                const ownerWrapper = document.getElementById('owner-filter-wrapper');
                if (ownerInput.value.trim() !== '') {
                    ownerWrapper.classList.add('has-value');
                } else {
                    ownerWrapper.classList.remove('has-value');
                }
            }

            // Clear search input
            document.getElementById('clear-search').addEventListener('click', function(e) {
                e.stopPropagation();
                document.getElementById('search-input').value = '';
                updateClearButtonVisibility();
                applyFilters();
            });

            // Clear owner filter
            document.getElementById('clear-owner').addEventListener('click', function(e) {
                e.stopPropagation();
                document.getElementById('filter-owner').value = '';
                updateClearButtonVisibility();
                applyFilters();
            });

            // Clear plan part filter
            document.getElementById('clear-planpart').addEventListener('click', function(e) {
                e.stopPropagation();
                // Uncheck all checkboxes
                selectedPlanParts.clear();
                document.querySelectorAll('#planpart-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updatePlanPartDisplay();
                applyFilters();
            });

            // Clear religion filter
            document.getElementById('clear-religion').addEventListener('click', function(e) {
                e.stopPropagation();
                // Uncheck all checkboxes
                selectedReligions.clear();
                document.querySelectorAll('#religion-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateReligionDisplay();
                applyFilters();
            });

            // Clear sex filter
            document.getElementById('clear-sex').addEventListener('click', function(e) {
                e.stopPropagation();
                // Uncheck all checkboxes
                selectedSexes.clear();
                document.querySelectorAll('#sex-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                updateSexDisplay();
                applyFilters();
            });

            // Clear all filters
            document.getElementById('clear-all-filters').addEventListener('click', function(e) {
                e.stopPropagation();

                // Clear text inputs
                document.getElementById('search-input').value = '';
                document.getElementById('filter-owner').value = '';

                // Clear select
                document.getElementById('filter-map').value = '';

                // Clear all multiselect filters
                selectedPlanParts.clear();
                selectedReligions.clear();
                selectedSexes.clear();

                // Uncheck all checkboxes
                document.querySelectorAll('#planpart-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                document.querySelectorAll('#religion-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
                document.querySelectorAll('#sex-multiselect input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });

                // Update multiselect displays
                updatePlanPartDisplay();
                updateReligionDisplay();
                updateSexDisplay();

                // Update clear button visibility for text inputs
                updateClearButtonVisibility();

                // Apply filters (will show all data)
                applyFilters();
            });

            // Add click handlers to table headers for sorting
            document.querySelectorAll('#data-table th[data-sort]').forEach(th => {
                th.addEventListener('click', function() {
                    const column = this.getAttribute('data-sort');
                    handleSort(column);
                });
            });

            // Initialize sort indicators
            updateSortIndicators();

            // ========================================
            // CSV DOWNLOAD
            // ========================================

            const csvDownloadToggle = document.getElementById('csv-download-toggle');
            const csvDownloadMenu = document.getElementById('csv-download-menu');
            const csvFilteredOption = document.getElementById('csv-filtered-option');
            const csvFilteredCount = document.getElementById('csv-filtered-count');

            // Toggle CSV dropdown menu
            csvDownloadToggle.addEventListener('click', function(e) {
                e.stopPropagation();
                csvDownloadMenu.classList.toggle('show');
            });

            // Close CSV menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!csvDownloadToggle.contains(e.target) && !csvDownloadMenu.contains(e.target)) {
                    csvDownloadMenu.classList.remove('show');
                }
            });

            // CSV export function
            function exportToCSV(data, filename) {
                // Collect all unique property keys from all features
                const allKeys = new Set();
                data.forEach(feature => {
                    if (feature.properties) {
                        Object.keys(feature.properties).forEach(key => {
                            // Skip internal/technical properties
                            if (key !== 'source_layer' && key !== 'Layer order' && key !== 'fid') {
                                allKeys.add(key);
                            }
                        });
                    }
                });

                // Convert to array preserving original GeoJSON property order
                const headers = ['Plan year', ...Array.from(allKeys)];

                // Escape CSV value
                const escapeCsv = (value) => {
                    if (value === null || value === undefined) return '';
                    const str = String(value);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str.replace(/"/g, '""')}"`;
                    }
                    return str;
                };

                // Build CSV content
                let csv = headers.map(escapeCsv).join(',') + '\n';

                data.forEach(feature => {
                    const props = feature.properties || {};

                    // Determine plan year from source_layer
                    const planYear = props.source_layer === 'plan_1888_plots' ? '1888' : '1891';

                    const row = headers.map(header => {
                        if (header === 'Plan year') {
                            return escapeCsv(planYear);
                        }
                        return escapeCsv(props[header] || '');
                    });

                    csv += row.join(',') + '\n';
                });

                // Download file with BOM for Excel compatibility
                const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }

            // Get current filtered data from table
            function getCurrentFilteredData() {
                const filtered = [];
                document.querySelectorAll('#data-table tbody tr').forEach(row => {
                    const fid = row.dataset.fid;
                    const sourceLayer = row.dataset.sourceLayer;
                    const feature = allTableData.find(f =>
                        f.properties.fid == fid &&
                        f.properties.source_layer === sourceLayer
                    );
                    if (feature) {
                        filtered.push(feature);
                    }
                });
                return filtered;
            }

            // Handle CSV menu item clicks
            document.querySelectorAll('.download-menu-item').forEach(item => {
                item.addEventListener('click', function() {
                    const csvType = this.getAttribute('data-csv-type');
                    const date = new Date().toISOString().split('T')[0];

                    if (csvType === 'all') {
                        exportToCSV(allTableData, `radashkovichy_all_${date}.csv`);
                    } else if (csvType === 'filtered') {
                        const filteredData = getCurrentFilteredData();
                        exportToCSV(filteredData, `radashkovichy_filtered_${date}.csv`);
                    }

                    csvDownloadMenu.classList.remove('show');
                });
            });

            // Update CSV filtered option visibility
            function updateCSVFilteredOption() {
                const filteredCount = document.querySelectorAll('#data-table tbody tr').length;
                const totalCount = allTableData.length;

                if (filteredCount < totalCount) {
                    csvFilteredOption.style.display = 'block';
                    csvFilteredCount.textContent = filteredCount;
                } else {
                    csvFilteredOption.style.display = 'none';
                }
            }

            // ========================================
            // FILTERS TOGGLE
            // ========================================

            // Toggle filters visibility
            document.getElementById('filters-toggle').addEventListener('click', function() {
                const filtersContent = document.getElementById('filters-content');
                const filtersIcon = document.getElementById('filters-toggle-icon');
                filtersContent.classList.toggle('collapsed');
                filtersIcon.classList.toggle('collapsed');
            });


            // ========================================
            // MAP SCALE
            // ========================================

            L.control.scale({
                imperial: false,
                metric: true,
                position: 'bottomleft'
            }).addTo(map);

            // ========================================
            // SCROLL TO MAP BUTTON
            // ========================================

            const scrollToMapBtn = document.getElementById('scroll-to-map');
            const mapSection = document.getElementById('map-section');
            const tableSection = document.getElementById('table-section');

            // Show/hide button based on scroll position
            function updateScrollToMapButton() {
                const mapRect = mapSection.getBoundingClientRect();
                const tableRect = tableSection.getBoundingClientRect();

                // Show button when table starts appearing in viewport (top 2/3 of screen)
                // This makes button appear earlier, when user is scrolling to table
                const triggerPoint = window.innerHeight * 2 / 3;

                if (tableRect.top < triggerPoint) {
                    scrollToMapBtn.classList.add('show');
                } else {
                    scrollToMapBtn.classList.remove('show');
                }
            }

            // Scroll to map on button click
            scrollToMapBtn.addEventListener('click', function() {
                mapSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            });

            // Listen to scroll events
            window.addEventListener('scroll', updateScrollToMapButton);

            // Initial check
            updateScrollToMapButton();
        });
    </script>

    <footer>
        <div class="footer-content">
            <div class="footer-section">
                This research has received funding from the Economic Recovery and Resilience Plan "New Generation Lithuania" under grant agreement No. 10-036-T-0006.
            </div>
            <div class="footer-section">
                Contact: <a href="mailto:radashkovichy@gmail.com">radashkovichy@gmail.com</a>
            </div>
            <div class="footer-section">
                &copy; <span id="current-year"></span>
            </div>
        </div>
    </footer>

    <script>
        // Set current year dynamically
        document.getElementById('current-year').textContent = new Date().getFullYear();
    </script>
</body>
</html>
